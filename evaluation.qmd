# Évaluation des résultats

## Évaluation de la robustesse

Il est utile d'évaluer la robustesse des résultats obtenus. On peut le faire avec un ré-échantillonnage aléatoire avec remise ([*bootstrap*](https://fr.wikipedia.org/wiki/Bootstrap_(statistiques))) qui va simuler de la variation et permettre ainsi de quantifier la sensibilité des résultats aux données de l'échantillon observé. Cette méthode permet d'obtenir pour chaque branche de l'arbre la proportion d'arbres ré-échantillonnés qui contiennent cette branche et ainsi d'identifier les branches reposant sur un faible nombre de données.

On peut par exemple évaluer nos [résultats obtenus par UPGMA](distance.qmd#sec-upgma).

```{r}
library(tidyverse)
library(phangorn)
library(TreeTools)
lx_phy <- ReadAsPhyDat("lx_phy_multi.nex")
lx_upgma <- read.tree("lx_upgma.tree")
```

Il faut au préalable récupérer la matrice de données. C'est totalement redondant mais il s'agit d'une contrainte technique.
Il faut en plus définir une fonction qui sera appliquée à chaque échantillon, ici on utilise la composition de `phyDat()`, `Hamming()` puis `upgma()`. On définit également à l'avance le nombre de ré-échantillonnages à effectuer, ici 1000.

```{r}
lx_m <- PhyDatToMatrix(lx_phy)
boot_upgma_hamming <- function(x) {
  upgma(Hamming(MatrixToPhyDat(x)))
}
n_bs <- 1000
```

On peut alors lancer la procédure de ré-échantillonnage sur l'arbre obtenu par UPGMA et la matrice de données. Même avec 1000 ré-échantillonnages, on obtient les résultats en un temps très court.

::: {.column-margin}
La fonction `set.seed()` permet de fixer la [graine aléatoire](https://fr.wikipedia.org/wiki/Graine_al%C3%A9atoire) et d'assurer la reproductibilité des résultats.
:::

```{r}
set.seed(123456)
lx_upgma_bs <- boot.phylo(lx_upgma,
  lx_m,
  boot_upgma_hamming,
  B = n_bs,
  trees = TRUE,
  quiet = TRUE
)
```

On peut ainsi obtenir le nombre de ré-échantillonnages où chacun des clades de l'arbre par UPGMA apparaît, les transformer en proportions, et affecter ces valeurs aux nœuds internes de l'arbre. On peut alors les afficher sur le dendrogramme.

```{r}
upgma_bs_scores <- prop.clades(lx_upgma, lx_upgma_bs$trees, rooted = TRUE)
upgma_support_pct <- upgma_bs_scores / n_bs
lx_upgma$node.label <- upgma_support_pct
plot(lx_upgma, show.node.label = TRUE)
```

Une autre méthodes consiste à directement afficher les résultats avec `plotBS()`.

```{r}
plotBS(lx_upgma, lx_upgma_bs$trees)
```

On peut choisir de n'afficher que les valeurs supérieures à un certain seuil, typiquement 70%.

```{r}
upgma_support_pct[upgma_support_pct < .7] <- NA
lx_upgma$node.label <- upgma_support_pct
plot(lx_upgma, show.node.label = TRUE)
```

Ou plus simplement avec `plotBS()`:

```{r}
plotBS(lx_upgma, lx_upgma_bs$trees, p = 70)
```


## Résumer l'accord entre des résultats

Une analyse phylogénétique résulte souvent non pas en un arbre unique mais en un ensemble d'arbres. Comme ce n'est pas le cas de nos exemples jusqu'ici, générons un ensemble de 10 arbres aléatoires.

```{r}
trees <- map(1:3, ~ rtree(n = 9))
trees <- as.multiPhylo(c(trees[1], trees[1], trees[1], trees, trees))
```

Il est possible de résumer l'accord entre ces arbres par un arbre consensus qui ne contient que les clades présents dans une proportion *p* des arbres. Un arbre consensus est donc normalement moins résolu que les arbres obtenus.

Un arbre consensus strict ne contient que les clades présents dans *tous* les arbres (*p* = 1). Sans surprise, on obtient un «râteau».

::: {.column-margin}
Un arbre consensus n'a pas en principe de longueurs de branches.
:::

```{r}
trees_sc <- consensus(trees, p = 1)
plot(trees_sc)
```

Un arbre consensus majoritaire contient lui les clades présents dans la majorité (*p* ≥ .5) des arbres.

```{r}
trees_mc <- consensus(trees, p = .5)
plot(trees_mc)
```

## Mesures d'homoplasie

Il est possible de calculer l'indice de cohérence (*consistency index*, ci) d'un caractère avec un arbre comme le rapport de l'amplitude *m* du caractère, c'est-à-dire le nombre minimal de transformations nécessaire pour rendre compte de ses états possibles, sur le nombre de pas (transformations) *s* observé pour ce caractère. L'amplitude *m* d'un caractère avec *k* états possible est égal à *k* - 1.

$ci = \frac{m}{s}$

La fonction `CI()` avec l'option `sitewise` permet d'obtenir l'index de cohérence de chaque caractère d'une matrice phylogénétique. On obtient une valeur `NaN` quand il y a une division par 0, dans les cas d'un caractère sans transformation qui présente le même état dans tous les taxons.

```{r}
lx_bab <- read.tree("lx_bab.tree")
ci <- CI(lx_bab, lx_phy, sitewise = TRUE)
ci
```

Le nombre d'homoplasies *h* pour un caractère s'obtient par
$h = l - r$. La valeur de *r* se calcule avec une fonction cachée de `phangorn`, et celle de *l* avec la fonction `sankoff()` et l'option `site = "site"`. En raison de la manière dont sont traités en interne les caractères de la matrice phylogénétique, il faut jouer avec les index de l'objet `PhyDat` pour bien récupérer la liste complète des valeurs. 

```{r}
m <- phangorn:::lowerBound(lx_phy)[attr(lx_phy, "index")]
s <- sankoff(lx_bab, lx_phy, site = "site")[attr(lx_phy, "index")]
h <- s - m
h
sum(h)
```

On peut alors obtenir le numéro des caractères présentant de l'homoplasie:
```{r}
which(h > 0)
```

L'indice de cohérence CI de l'ensemble des caractères est lui le rapport de la somme *M* des *m* sur la somme *S* des *s* de tous les *N* caractères.

$$CI = \frac{M}{S}, M = \sum^N_{i=1} m_i, S = \sum^N_{i=1} s_i$$

```{r}
CI(lx_bab, lx_phy)
sum(m)/sum(s)
```

*S* est le nombre total de pas ou longueur de l'arbre. On peut l'obtenir avec la fonction `sankoff()` sans option.
```{r}
sum(s)
sankoff(lx_bab, lx_phy)
```

Cet indice de cohérence est une mesure du degré d'homoplasie des données sur un arbre. Plus le score est bas, plus l'arbre contient d'homoplasie, et une valeur de 1 indique une absence totale d'homoplasie. Les caractères autapomorphiques ont un ci de 1.

L'indice de cohérence est cependant problématique car sa valeur minimale n'est en fait pas 0, ce qui ne permet donc pas de l'utiliser pour évaluer correctement le degré d'homoplasie.

Il est possible d'utiliser à la place un indice de cohérence ré-échelonné (*rescaled consistency index*, rci) par l'introduction de *g*, le nombre maximal de transformations pour un caractère, ce qui correspond cas où toutes les transformations auraient lieu sur les branches terminales:

$$rci = \frac{g-s}{g-m}\frac{m}{s} = \frac{g-s}{g-m}ci$$

Les valeurs de *g* s'obtient avec une autre fonction cachée de `phangorn`.
```{r}
phangorn:::upperBound(lx_phy)[attr(lx_phy, "index")]
```

Mais il est plus simple de calculer la partie gauche de la formule du rci avec la fonction `RI()`.
```{r}
rci <- RI(lx_bab, lx_phy, sitewise = TRUE) * CI(lx_bab, lx_phy, sitewise = TRUE)
rci
```

L'indice de cohérence ré-échelonné RCI pour l'ensemble des caractères se calcule comme suit:

$$RCI = \frac{G-S}{G-M}\frac{M}{S}, G = \sum^N_{i=1} g_i$$

```{r}
CI(lx_bab, lx_phy) * RI(lx_bab, lx_phy)
```

La partie gauche des formules d'indice de cohérence est lui-même une mesure appelée indice de rétention (*retention index*, ri, RI). Il mesure la proportion de synapomorphies potentielles effectivement retenues comme telle sur un arbre, ou le rapport du nombre d'homoplasies observées sur le nombre d'homoplasies possibles. Les caractères autapomorphiques ont un ri de 0. 

```{r}
RI(lx_bab, lx_phy, sitewise = TRUE)
RI(lx_bab, lx_phy)
```


Il est ainsi possible de comparer les scores de différents arbres, par exemple celui obtenu par parcimonie et celui obtenu par UPGMA.
```{r}
tr <- c(lx_bab, lx_upgma)
nms <- c("bab", "upgma")
comp_tb <- map(seq_along(tr), function(i){
  m <- phangorn:::lowerBound(lx_phy)[attr(lx_phy, "index")]
  s <- sankoff(tr[[i]], lx_phy, site = "site")[attr(lx_phy, "index")]
  h <- s - m
  CI_x <- CI(tr[[i]], lx_phy)
  RI_x <- RI(tr[[i]], lx_phy)
  df <- tribble(
    ~var, ~value,
  "S", sum(s),
  "H", sum(h),
  "CI", CI_x,
  "RCI", CI_x * RI_x,
  "RI", RI_x
  )
  colnames(df)[2] <- nms[i]
  df
}) %>% 
  reduce(left_join)
```
```{r}
#| echo: false
rmarkdown::paged_table(comp_tb)
```
Sans surprise, notre arbre obtenu par parcimonie est plus parcimonieux: il est plus court (nombre de pas) et contient moins d'homoplasies, et il est plus cohérent et a plus de rétention.
