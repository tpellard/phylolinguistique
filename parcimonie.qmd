# Méthodes de parcimonie

Contrairement aux méthodes par distance, les méthodes de parcimonie ne construisent pas un arbre pas à pas mais recherchent le ou les arbre optimaux parmi l'ensemble des arbres possibles. Le critère d'évaluation des arbres est celui de [maximum de parcimonie](https://fr.wikipedia.org/wiki/Maximum_de_parcimonie): l'arbre préféré est celui qui suppose le moins de changements. Autrement dit, on suppose qu'un changement partagé s'est a priori produit dans l'ancêtre commun plutôt que de manière indépendante dans des langues différentes. Les méthodes de parcimonie cherchent donc à minimiser les homoplasies ou innovations parallèles.

Les méthodes de parcimonie sont plus complexes que celles par distance, mais elles restent néanmoins beaucoup plus simples que les méthodes probabilistes. Si elles reposent sur peu de suppositions et ont une solide base épistémologique, ces méthodes posent des problèmes statistiques et peuvent donner des résultats faux dans [certaines conditions](https://fr.wikipedia.org/wiki/Attraction_des_longues_branches).

Commençons par importer de nouveau la matrice de traits à états multiples que nous avions sauvegardée [précédemment](import.qmd#lst:save).

```{r}
library(tidyverse)
library(phangorn)
library(TreeTools)
lx_phy <- ReadAsPhyDat("lx_phy_multi.nex")
```

Parmi les différentes variantes de parcimonie, la plus simple (dite «de Wagner») autorise tous les changements sans restriction et les traite à égalité sans pondération, orientation, ou ordre. Dans le cas d'une matrice de traits binaires, les changements `0` \> `1` et `1` \> `0` sont ainsi traités de manière identique, et il n'est pas nécessaire de connaitre l'état ancestral de chaque trait et si un changement constitue une innovation ou une réversion, ce qui implique que le résultat est un arbre non enraciné.

::: column-margin
::: callout-caution
## À faire

Inclure les autres types de parcimonie.
:::
:::

La comparaison des arbres possibles à la recherche du plus parcimonieux est une procédure longue, et avec beaucoup de taxons, il est nécessaire d'utiliser une méthode heuristique comme le *Parsimony Ratchet* avec `pratchet()`. Le résultat est un objet `multiPhylo` pouvant contenir plusieurs arbres si l'on a précisé l'option `all = TRUE`, bien qu'ici il n'y en ait qu'un seul.

::: column-margin
::: callout-caution
## À faire

Vérifier le traitement des données manquantes et celui des polymorphismes pour les données à états multiples.
:::
:::

```{r}
lx_pratchet <- pratchet(lx_phy, trace = 0, method = "sankoff", all = TRUE)
lx_pratchet
plot(lx_pratchet, "unrooted")
```

::: column-margin
::: {.callout-tip appearance="simple"}
L'option `trace` permet de choisir la quantité d'information à afficher concernant la recherche de l'arbre.
:::
::: {.callout-note appearance="simple"}
L'option `method = "sankoff"` permet d'utiliser l'algorithme de Sankoff qui est plus complexe mais plus général également.
:::
:::

Il est nécessaire de calculer explicitement la longueur des différentes branches. La fonction `acctran()` permet de calculer la longueur par la méthode de transformation accélérée qui assigne les changements le plus haut possible dans l'arbre et favorise l'interprétation des homoplasies comme des réversions.

```{r}
lx_pratchet <- acctran(lx_pratchet, lx_phy)
lx_pratchet
plot(lx_pratchet, "unrooted")
```

On peut ensuite enraciner l'arbre, par exemple avec `midpoint()`, qui place la racine à mi-chemin des deux taxons les plus divergents. Cette méthode présuppose cependant que l'évolution a lieu a taux constant et que la topologie est équilibrée (les taxons sont bien distribués entre les différents clades).

```{r}
plot(midpoint(lx_pratchet))
```

Une autre méthode nécessite de déterminer un extra-groupe ou groupe externe (*outgroup*). La fonction `root()` permet de procéder à l'enracinement en indiquant le numéro ou le nom du taxon constituant le groupe externe, par exemple «Violet». Cela présuppose bien sûr qu'il ait été inclus dans l'analyse de départ.

```{r}
lx_pratchet <- root(lx_pratchet, "Violet")
plot(lx_pratchet)
```

S'il n'y a pas de groupe externe mais que l'on connaît les états ancestraux, on peut rajouter aux données un taxon fictif possédant l'état ancestral pour tous les caractères, par exemple `1` partout. On obtient plusieurs arbres cette fois-ci, et chacun est manipulable en utilisant son index numérique.

```{r}
lx_phy2 <- lx_phy %>% 
  PhyDatToMatrix() %>% 
  rbind("Fictif" = rep("1", ncol(.))) %>% 
  MatrixToPhyDat()
lx_pratchet <- pratchet(lx_phy2, trace = 0, method = "sankoff", all = TRUE) %>% 
  acctran(lx_phy2) %>% 
  root("Fictif")
lx_pratchet
lx_pratchet[[1]]
plot(lx_pratchet)
```

Il suffit ensuite de supprimer le taxon fictif de l'arbre.

```{r}
lx_pratchet <- drop.tip(lx_pratchet, "Fictif")
plot(lx_pratchet)
```

On peut alors sauvegarder les résultats (arbres avec longueurs de branches) dans un fichier au [format Newick](https://fr.wikipedia.org/wiki/Newick). Sauvegardons le résultat également comme un objet R, afin de conserver des propriétés intéressantes pour plus tard.

```{r}
write.tree(lx_pratchet, "lx_pratchet.tree")
write_rds(lx_pratchet, "lx_pratchet.rds")
```
