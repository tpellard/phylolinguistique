[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Phylolinguistique avec R",
    "section": "",
    "text": "Ce tutoriel est une introduction à la phylolinguistique, c’est-à-dire aux méthodes phylogénétiques appliquées à la linguistique, à l’aide du logiciel libre R. Le but est d’apprendre à des linguistes à utiliser les méthodes de classification et d’inférence phylogénétique courantes en biologie.\n\n\n\n\n\n\n\n\nVous pouvez visualiser ce site en version sombre à l’aide du bouton  du menu latéral droit.\n\n\n\nEn l’état, il s’agit avant tout d’un pense-bête pour moi-même ainsi que mes collègues et étudiants.\n\n\n\n\n\n\nAvertissement\n\n\n\nCe tutoriel est en construction. Il reste assez basique et, s’il pourra s’étoffer à l’avenir, il ne s’adresse pour l’instant pas aux néophytes complets. Les concepts de base de la linguistique historique et comparative comme de la phylogénétique sont rarement expliqués et le plus souvent présupposés, et il n’y a pas de références systématiques à la littérature scientifique pertinente.\n\n\n\n\n\n\n\n\nParticipez!\n\n\n\nN’hésitez pas à signaler un problème ou bien à faire part de vos commentaires sur Github via le lien du menu latéral gauche.\n\n\n\n\n\n\n\n\nNote technique\n\n\n\nCe tutoriel est réalisé avec Quarto, et le code R utilise le Tidyverse. Le code source est librement accessible sur Github."
  },
  {
    "objectID": "index.html#ressources",
    "href": "index.html#ressources",
    "title": "Phylolinguistique avec R",
    "section": "Ressources",
    "text": "Ressources\nLes ressources ci-dessous sont recommandées pour une (re)mise à niveau ou pour aller plus loin.\n\nPhylogénétique\nEn français, l’introduction à la systématique de Hervé (2020) constitue une bonne porte d’entrée, et Aubert (2017) est un manuel plus complet. On peut également recommander l’article de Gregory (2008) pour éviter les erreurs d’interprétations courantes des arbres phylogénétiques. Le cours en ligne Introduction à la biologie de l’évolution est également à signaler.\nPour aller plus loin, on peut consulter les manuels avancés de Darlu, Tassy & Zaragüeta i Bagils (2019) et Perrière & Brochier-Armanet (2010), ainsi que ceux en anglais de Felsenstein (2004), Lemey, Salemi & Vandamme (2009) et Brower & Schuh (2021).\nVoir aussi les tutoriels:\n\nAn Intro to Phylogenetic Tree Construction in R\nla vignette Estimating phylogenetic trees with phangorn\n\n\n\nLinguistique\nConcernant les applications à la linguistique, Atkinson & Gray (2005), Geisler & List (2013), et Jacques & List (2019) détaillent le transfert de concepts phylogénétiques entre la biologie et la linguistique.\nD’un point de vue pratique et technique, on peut recommander Dunn (2015), ainsi que l’excellent tutoriel en R de Goldstein (2020). Voir aussi le tutoriel Practical phylogenetic methods for linguistic typology.\n\n\nR\nLes manuels de Grolemund (2014) et de Wickham & Grolemund (2017) sont librement disponibles en ligne, et il existe une traduction en français de ce dernier (Wickham & Grolemund 2018).\nIl existe en outre de nombreux tutoriels en ligne, y compris en français, comme:\n\nIntroduction à R et au tidyverse\nBegin’R\nutilitR\nPréparation et manipulation de données dans R\n\n\n\n\n\nAtkinson, Quentin D. & Russell D. Gray. 2005. Curious parallels and curious connections: Phylogenetic thinking in biology and historical linguistics. Systematic Biology 54(4). 513‑526. https://doi.org/10.1080/10635150590950317.\n\n\nAubert, Damien. 2017. Classer le vivant: Les perspectives de la systématique évolutionniste moderne. Paris: Ellipses.\n\n\nBrower, Andrew V. Z. & Randall T. Schuh. 2021. Biological systematics: Principles and applications. 3ᵉ edn. Ithaca: Comstock.\n\n\nDarlu, Pierre, Pascal Tassy & René Zaragüeta i Bagils. 2019. La reconstruction phylogénétique: Concepts et méthodes. 2ᵉ edn. Paris: Éditions Matériologiques.\n\n\nDunn, Michael. 2015. Language phylogenies. In Claire Bowern & Bethwyn Evans (éd.), The Routledge handbook of historical linguistics, 190‑211. London: Routledge. https://doi.org/10.4324/9781315794013.\n\n\nFelsenstein, Joseph. 2004. Inferring phylogenies. Sunderland: Sinauer.\n\n\nGeisler, Hans & Johann-Mattis List. 2013. Do languages grow on trees? The tree metaphor in the history of linguistics. In Heiner Fangerau, Hans Geisler, Thorsten Halling & William Martin (éd.), Classification and evolution in biology, linguistics and the history of science, 111‑124. Stuttgart: Steiner.\n\n\nGoldstein. 2020. Indo-European phylogenetics with R: A tutorial introduction. Journal of Indo-European Linguistics. https://doi.org/10.1163/22125892-20201000.\n\n\nGregory, T. Ryan. 2008. Understanding evolutionary trees. Evolution: Education and Outreach 1(2). 121‑137. https://doi.org/10.1007/s12052-008-0035-x.\n\n\nGrolemund, Garrett. 2014. Hands-on programming with R: Write your own functions and simulations. Sebastopol: O’Reilly Media. https://rstudio-education.github.io/hopr/.\n\n\nHervé, Maxime. 2020. Systématique animale: D’Aristote aux phylogénies moléculaires. Histoire, concepts et méthodes de la classification. Louvain-la-Neuve: De Boeck Supérieur.\n\n\nJacques, Guillaume & Johann-Mattis List. 2019. Save the trees: Why we need tree models in linguistic reconstruction (and when we should apply them). Journal of Historical Linguistics 9(1). 128‑166. https://doi.org/10.1075/jhl.17008.mat.\n\n\nLemey, Philippe, Marco Salemi & Anne-Mieke Vandamme (éd.). 2009. The phylogenetic handbook: A practical approach to phylogenetic analysis and hypothesis testing. 2ᵉ edn. Cambridge: Cambridge University Press. https://doi.org/10.1017/CBO9780511819049.\n\n\nPerrière, Guy & Céline Brochier-Armanet. 2010. Concepts et méthodes en phylogénie moléculaire. Paris: Springer.\n\n\nWickham, Hadley & Garrett Grolemund. 2017. R for data science: Import, tidy, transform, visualize, and model data. Sebastopol: O’Reilly Media. http://r4ds.had.co.nz/.\n\n\nWickham, Hadley & Garrett Grolemund. 2018. R pour les data sciences: Importer, classer, transformer, visualiser et modéliser les données. Paris: Eyrolles."
  },
  {
    "objectID": "avanttout.html",
    "href": "avanttout.html",
    "title": "Avant tout chose",
    "section": "",
    "text": "Les linguistes ont pendant longtemps réalisé des classifications phylogénétiques des langues à la main. Toutefois cela devient rapidement impossible avec de larges jeux de données à moins de partir à la «cueillette de cerises» en sélectionnant intentionnellement un petit nombre de données, ce qui est la porte ouverte aux biais de sélection.\nMême pour les méthodes les plus simples, comme la lexicostatistique, qui peuvent être effectuées manuellement, l’analyse des données est longue et fastidieuse, et la moindre modification des données demande de recommencer à zéro. Il s’agit là typiquement d’une tâche pour un ordinateur.\n\n\nPour n taxons, il y a \\(\\frac{(2n-3)!}{2^{n-2}(n-2)!}\\) arbres racinés à embranchements binaires possibles. Pour 10 langues, il y a plus de 34 millions de possibilités.\n\n\n\n\nn\narbres\n\n\n\n2\n1\n\n\n3\n3\n\n\n4\n15\n\n\n5\n105\n\n\n6\n945\n\n\n7\n10395\n\n\n8\n135135\n\n\n9\n2027025\n\n\n10\n34459425\n\n\n20\n8.200795 × 1021\n\n\n\n30\n4.951798 × 1038\n\n\n\n40\n1.009847 × 1057\n\n\n\n50\n2.752921 × 1076\n\n\n\n\n\n\nEn outre, la plupart des méthodes d’inférence phylogénétique compare les différents arbres théoriquement possibles à la recherche du ou des arbres optimaux selon le critère choisi (maximum de parcimonie, de compatibilité, de vraisemblance, de probabilité postérieure). Or le nombre d’arbres à comparer devient vite astronomique en fonction du nombre de taxons (langues), si bien qu’il est le plus souvent impossible de comparer tous les arbres possibles, et il est nécessaire de recourir à des méthodes heuristiques complexes afin de trouver une solution approximative. Il est évidemment impossible de se passer d’un ordinateur pour cela.\nLe logiciel R, en plus d’être libre, gratuit et multi-plateforme, est particulièrement indiqué pour ce genre de travail. Il est spécialisé dans l’analyse quantitative et la visualisation de données, et il existe de nombreuses extensions dédiées à la phylogénétique."
  },
  {
    "objectID": "avanttout.html#installation-des-logiciels",
    "href": "avanttout.html#installation-des-logiciels",
    "title": "Avant tout chose",
    "section": "Installation des logiciels",
    "text": "Installation des logiciels\nIl est nécessaire avant toute chose d’installer le logiciel R si ce n’est pas déjà fait: https://cran.r-project.org/.\n\n\n\n\n\n\nL’utilisation de l’environnement de développement gratuit, libre et multiplateforme Rstudio est recommandée.\n\n\n\nIl est également nécessaire d’installer un certain nombre d’extensions R. Il suffit pour cela de saisir les commandes suivantes dans la console R.\n\ninstall.packages(\"tidyverse\")\ninstall.packages(\"ape\")\ninstall.packages(\"phangorn\")\ninstall.packages(\"TreeTools\")\n\nLes extensions ggtree et tanggle pour la visualisation avancée des arbres phylogénétiques nécessitent au préalable d’installer BiocManager.\n\ninstall.packages(\"BiocManager\")\nBiocManager::install(\"ggtree\")\nBiocManager::install(\"tanggle\")"
  },
  {
    "objectID": "import.html",
    "href": "import.html",
    "title": "\n1  Préparation des données\n",
    "section": "",
    "text": "La plupart des analyses phylolinguistiques utilisent des données lexicales. Une étape préalable à l’analyse phylogénétique consiste à déterminer quels mots sont cognats (homologues) et à les annoter. Cette tâche peut être grandement facilitée grâce à Edictor, un éditeur libre et gratuit de bases de données lexicales comparatives créé par Mattis List. Il permet entre autres d’annoter facilement les classes de cognats (ensembles de mots apparentés) dans un navigateur internet en ligne ou hors ligne. Un tutoriel en ligne détaillé est disponible en ligne."
  },
  {
    "objectID": "import.html#import",
    "href": "import.html#import",
    "title": "\n1  Préparation des données\n",
    "section": "\n1.1 Import",
    "text": "1.1 Import\nEdictor permet de sauvegarder les données traitées sous forme d’un fichier tabulaire au format .tsv. Il est alors très simple de l’importer avec R, en prenant garde d’ignorer les lignes de commentaires à la fin marquées par #.\nTéléchargeons et importons pour l’exemple des données sur les variétés bai fournies dans Edictor. Comme la colonne MORPHEMES est entièrement vide, on peut immédiatement la supprimer.\n\nlibrary(tidyverse)\nurl &lt;- \"https://raw.githubusercontent.com/digling/edictor/master/data/BAI.tsv\"\ndownload.file(url, \"BAI.tsv\")\nlx_orig &lt;- read_tsv(\"BAI.tsv\", comment = \"#\")\nlx &lt;- lx_orig %&gt;%\n  select(-MORPHEMES)\n\nL’information sur les classes de cognats se trouve dans la colonne COGIDS (les colonnes ID et TOKENS ne sont pas montrées ci-dessous).\n\n\n\n\n  \n\n\n\nComme il s’agit de faire un exemple et non une réelle analyse phylogénétique, je propose de renommer les langues de manière arbitraire afin de ne pas induire en erreur les personnes qui tomberaient par hasard sur les résultats de nos analyses et les diffuseraient sans le contexte de ce tutoriel.\n\nlx &lt;- lx %&gt;%\n  mutate(DOCULECT = case_when(\n    DOCULECT == \"Gongxing\" ~ \"Magenta\",\n    DOCULECT == \"Jinman\" ~ \"Cyan\",\n    DOCULECT == \"Mazhelong\" ~ \"Jaune\",\n    DOCULECT == \"Dashi\" ~ \"Vert\",\n    DOCULECT == \"Zhoucheng\" ~ \"Violet\",\n    DOCULECT == \"Jinxing\" ~ \"Orange\",\n    DOCULECT == \"Tuolo\" ~ \"Rouge\",\n    DOCULECT == \"Enqi\" ~ \"Bleu\",\n    DOCULECT == \"Ega\" ~ \"Indigo\",\n  ))"
  },
  {
    "objectID": "import.html#conversion",
    "href": "import.html#conversion",
    "title": "\n1  Préparation des données\n",
    "section": "\n1.2 Conversion",
    "text": "1.2 Conversion\nLes seules colonnes qui vont nous intéresser ici sont CONCEPTID (identifiant unique du concept), DOCULECT (langue) et COGIDS (classe de cognats). Par ailleurs, certaines langues ont plusieurs formes (variantes?) pour une même classe de cognats, mais l’information qui nous intéresse est simplement la présence ou non d’un cognat, on peut donc supprimer les lignes superflues correspondantes avec la fonction distinct().\n\nlx &lt;- lx %&gt;% \n  select(CONCEPTID, DOCULECT, COGIDS) %&gt;%\n  distinct()\n\n\n\n\n\n  \n\n\n\nLe but est de construire une matrice indiquant quels mots sont cognats, mais plusieurs types de matrices sont possibles en fonction de l’information désirée. Ce n’est pas le cas le plus courant, mais on peut vouloir indiquer si une racine particulière, avec un identifiant COGIDS unique, existe ou non, quel que soit le concept qu’elle exprime dans la langue. On va pour cela pivoter notre tableau (et non le transposer): les valeurs de COGIDS vont devenir des colonnes remplies en fonction de la valeur de CONCEPTID dans chaque DOCULECT. Si pour une valeur de COGIDS donnée il n’y a pas de CONCEPTID associé dans un DOCULECT, c’est-à-dire que la langue n’a aucun concept avec une forme appartenant à cette classe de cognat, on remplit la cellule avec un 0, sinon avec le nombre de concepts pour lesquels on trouve le cognat grâce à la fonction length. Ce nombre est en général 1, mais en théorie, il peut être supérieur, et il faut donc remplacer les nombres supérieurs à 1 par 1. On peut au préalable ordonner les données par ordre de la valeur de COGIDS. On obtient ainsi un tableau au format large avec les langues (taxons) en lignes et les classes de cognats (caractères) en colonnes.\n\nlx_roots &lt;- lx %&gt;%\n  select(CONCEPTID, DOCULECT, COGIDS) %&gt;%\n  distinct() %&gt;%\n  arrange(COGIDS) %&gt;%\n  pivot_wider(\n    names_from = COGIDS,\n    values_from = CONCEPTID,\n    values_fill = 0,\n    values_fn = length\n  ) %&gt;%\n  mutate(across(-DOCULECT, ~ ifelse(.x &gt; 1, 1, .x)))\n\n\n\n\n\n  \n\n\n\nToutefois, il est plus courant en phylolinguistique de s’intéresser aux cas ou un même concept est exprimé par un cognat entre langues. Il est préférable dans ce cas de produire une matrice avec des caractères binaires (la langue possède-t-elle (1) ou non (0) un cognat pour une classe donnée?) plutôt qu’avec des caractères à états multiples (quelle est la classe de cognat de la forme de chaque langue?). Cela permet de traiter sans problème les cas de polymorphisme (plusieurs formes pour un même concept), comme on peut en trouver dans nos données d’exemple.\nLa conversion est un plus complexe et nécessite de pivoter trois fois notre tableau en faisant attention aux éventuelles données manquantes (les cas où un concept n’apparaît pas dans dans la liste d’une langue). Dans un premier temps, on utilise les valeurs de DOCULECT comme noms de colonnes et on remplit de 0 si la langue n’a pas de forme pour une classe de cognat et un concept donnés, et avec 1 sinon. Il faut rajouter une colonne fantoche auparavant avec par exemple rowid_to_column afin de conserver les colonnes CONCEPT et COGIDS et utiliser cette colonne fantoche pour remplir les cellules. On repivote ensuite notre tableau dans l’autre sens en mettant l’information binaire (présence ou non d’une même association entre un concept et une classe de cognat) dans une colonne VALUE dont on convertit le type de numérique à caractère. Pour chaque langue et concept, s’il n’y aucune classe de cognat et donc uniquement des 0 dans VALUE, c’est que les données sont manquantes, et on remplace les 0 par ?, le symbole standard pour les données manquantes. Enfin on peut pivoter à nouveau le tableau, cette fois-ci en utilisant une nouvelle valeur concaténant CONCEPT et COGIDS comme noms de colonnes et en abandonnant ces deux colonnes d’origine. On obtient ainsi un tableau au format large avec les langues (taxons) en lignes et les combinaisons entre concepts et classes de cognats en colonnes, avec 1 pour «présence», 0 pour «absence», et ? pour «donnée manquante».\n\nlx_cogs &lt;- lx %&gt;%\n  rowid_to_column() %&gt;%\n  pivot_wider(\n    names_from = DOCULECT,\n    values_from = rowid,\n    values_fill = 0,\n    values_fn = length\n  ) %&gt;%\n  pivot_longer(cols = !(CONCEPTID | COGIDS), names_to = \"DOCULECT\", values_to = \"VALUE\") %&gt;%\n  mutate(VALUE = as.character(VALUE)) %&gt;%\n  group_by(CONCEPTID, DOCULECT) %&gt;%\n  mutate(VALUE = ifelse(sum(VALUE != \"0\") == 0, \"?\", VALUE)) %&gt;%\n  ungroup() %&gt;%\n  mutate(id = paste0(CONCEPTID, \"_\", COGIDS)) %&gt;%\n  select(DOCULECT, id, VALUE) %&gt;%\n  pivot_wider(\n    names_from = id,\n    values_from = VALUE\n  )\n\n\n\n\n\n  \n\n\n\nPour finir de convertir nos données en une matrice phylogénétique prêtre à l’analyse, il suffit de les convertir en objet matriciel puis enfin d’utiliser la fonction phyDat() de phangorn en précisant l’ensemble des valeurs possibles de COGIDS et le nom des colonnes (langues).\n\nlibrary(phangorn)\nlx_phy &lt;- lx_cogs %&gt;%\n  column_to_rownames(\"DOCULECT\") %&gt;%\n  as.matrix() %&gt;%\n  phyDat(\n    type = \"USER\",\n    levels = c(\"0\", \"1\"),\n    names = names(.)\n  )\nlx_phy\n\n9 sequences with 205 character and 31 different site patterns.\nThe states are 0 1 \n\n\nOn peut alors sauvegarder la matrice obtenue avec la fonction write.phyDat(). Plusieurs formats courants comme Nexus ou Phylip sont possibles. Pour une simple matrice comme la nôtre, l’option par défaut (Phylip) est suffisante (le réimport d’un fichier nexus à traits binaires pose en autre des problèmes non encore résolus).\n\nwrite.phyDat(lx_phy, \"lx_phy.phy\", format = \"phylip\")\n\n\n\n\n\n\n\n\n\nÀ faire\n\n\n\nRégler le problème de lecture des fichiers nexus binaires\n\n\nCette conversion étant un peu fastidieuse, il est plus pratique de créer une fonction réutilisable pour tout le processus de conversion d’un fichier .tsvau format Edictor vers une matrice de traits binaires au format phyDat.\n\nas_phyDat2_edictor &lt;- function(dt) {\n  dt %&gt;%\n    rowid_to_column() %&gt;%\n    pivot_wider(\n      names_from = DOCULECT,\n      values_from = rowid,\n      values_fill = 0,\n      values_fn = length\n    ) %&gt;%\n    pivot_longer(cols = !(CONCEPTID | COGIDS), names_to = \"DOCULECT\", values_to = \"VALUE\") %&gt;%\n    mutate(VALUE = as.character(VALUE)) %&gt;%\n    group_by(CONCEPTID, DOCULECT) %&gt;%\n    mutate(VALUE = ifelse(sum(VALUE != \"0\") == 0, \"?\", VALUE)) %&gt;%\n    ungroup() %&gt;%\n    mutate(id = paste0(CONCEPTID, \"_\", COGIDS)) %&gt;%\n    select(DOCULECT, id, VALUE) %&gt;%\n    pivot_wider(\n      names_from = id,\n      values_from = VALUE\n    ) %&gt;%\n    column_to_rownames(\"DOCULECT\") %&gt;%\n    as.matrix() %&gt;%\n    phyDat(\n      type = \"USER\",\n      levels = c(\"0\", \"1\"),\n      names = names(.)\n    )\n}\n\n\nas_phyDat2_edictor(lx)\n\n9 sequences with 205 character and 31 different site patterns.\nThe states are 0 1"
  },
  {
    "objectID": "distance.html",
    "href": "distance.html",
    "title": "\n2  Méthodes par distance\n",
    "section": "",
    "text": "Les méthodes par distance sont simples à comprendre et à implémenter car elles reposent en général sur un algorithme qui ne compare pas les arbres possibles mais construit un arbre unique.\nToutefois, elles ont plusieurs faiblesses qui font qu’elles sont d’un usage limité aujourd’hui:\nLes méthodes par distance ne peuvent donc pas être recommandées pour l’analyse phylogénétique."
  },
  {
    "objectID": "distance.html#calcul-des-distances",
    "href": "distance.html#calcul-des-distances",
    "title": "\n2  Méthodes par distance\n",
    "section": "\n2.1 Calcul des distances",
    "text": "2.1 Calcul des distances\nCommençons par importer de nouveau la matrice de traits que nous avions sauvegardée précédemment.\n\nlibrary(tidyverse)\nlibrary(phangorn)\nlx_phy &lt;- read.phyDat(\"lx_phy.phy\",\n  type = \"USER\",\n  levels = c(\"0\", \"1\")\n)\n\nIl est trivial de calculer la distance observée, ou p-distance, sur une telle matrice. Il suffit de calculer pour chaque paire de langues le rapport entre nombre de caractères différents et le nombre de caractères total avec la fonction dist.hamming(). On peut exclure les données manquantes du calcul de distance pour chaque paire de langues avec l’option exclude = \"pairwise\".\n\nlx_dist &lt;- dist.hamming(lx_phy, exclude = \"pairwise\")\n\nLa diagonale des distances de chaque langue avec elle-même est bien sûr 0, et la matrice de distance est symétrique, on peut donc se passer d’afficher l’un des deux triangles.\n\nCodelx_dist_m &lt;- as.matrix(lx_dist)\nlx_dist_m[upper.tri(lx_dist_m)] &lt;- NA\noptions(knitr.kable.NA = \"\")\nknitr::kable(lx_dist_m, digits = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMagenta\nCyan\nJaune\nVert\nViolet\nOrange\nRouge\nBleu\nIndigo\n\n\n\nMagenta\n0.00\n\n\n\n\n\n\n\n\n\n\nCyan\n0.40\n0.00\n\n\n\n\n\n\n\n\n\nJaune\n0.51\n0.26\n0.00\n\n\n\n\n\n\n\n\nVert\n0.47\n0.24\n0.12\n0.00\n\n\n\n\n\n\n\nViolet\n0.50\n0.23\n0.13\n0.13\n0.00\n\n\n\n\n\n\nOrange\n0.45\n0.23\n0.15\n0.10\n0.14\n0.00\n\n\n\n\n\nRouge\n0.34\n0.28\n0.32\n0.31\n0.27\n0.27\n0.00\n\n\n\n\nBleu\n0.39\n0.16\n0.26\n0.23\n0.15\n0.13\n0.20\n0.00\n\n\n\nIndigo\n0.39\n0.18\n0.24\n0.25\n0.21\n0.22\n0.23\n0.18\n0\n\n\n\n\n\nOn peut alternativement afficher la matrice des similitudes en retranchant les distances de 1, voir des pourcentages en multipliant le résultat par 100. On obtient alors une matrice semblable à ce qu’on voit en lexicostatistique.\n\nlx_sim_m &lt;- (1 - as.matrix(lx_dist)) * 100\n\n\nCodelx_sim_m[upper.tri(lx_sim_m)] &lt;- NA\noptions(knitr.kable.NA = \"\")\nknitr::kable(lx_sim_m, digits = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMagenta\nCyan\nJaune\nVert\nViolet\nOrange\nRouge\nBleu\nIndigo\n\n\n\nMagenta\n100.00\n\n\n\n\n\n\n\n\n\n\nCyan\n60.00\n100.00\n\n\n\n\n\n\n\n\n\nJaune\n48.72\n74.36\n100.00\n\n\n\n\n\n\n\n\nVert\n52.82\n76.41\n87.69\n100.00\n\n\n\n\n\n\n\nViolet\n49.74\n77.44\n86.67\n86.67\n100.00\n\n\n\n\n\n\nOrange\n55.38\n76.92\n85.13\n90.26\n86.15\n100.00\n\n\n\n\n\nRouge\n66.15\n72.31\n68.21\n69.23\n73.33\n72.82\n100.00\n\n\n\n\nBleu\n60.51\n84.10\n73.85\n76.92\n85.13\n86.67\n80.00\n100.00\n\n\n\nIndigo\n60.51\n82.05\n75.90\n74.87\n78.97\n78.46\n76.92\n81.54\n100"
  },
  {
    "objectID": "distance.html#sec-upgma",
    "href": "distance.html#sec-upgma",
    "title": "\n2  Méthodes par distance\n",
    "section": "\n2.2 UPGMA",
    "text": "2.2 UPGMA\nL’algorithme de classification UPGMA (Unweighted pair group method with arithmetic mean) est le plus basique et le moins bon pour les classifications génétiques. Cette méthode présuppose notamment une «horloge moléculaire», c’est-à-dire que la vitesse de changement était constante, ce qui est faux en biologie comme en linguistique. Le résultat est un arbre dit ultramétrique où toutes les langues sont alignées au lieu d’être placées en fonction du nombre de changements avec des branches de longueur variées.\nNéanmoins cette méthode est simplissime: on groupe les taxons les plus proches ensemble, et la distance du groupe obtenu aux taxons restants est recalculée en faisant la moyenne des distances des éléments groupés, et on recommence jusqu’à n’avoir plus que deux groupes.\n\nlx_upgma &lt;- upgma(lx_dist)\nlx_upgma\n\n\nPhylogenetic tree with 9 tips and 8 internal nodes.\n\nTip labels:\n  Magenta, Cyan, Jaune, Vert, Violet, Orange, ...\n\nRooted; includes branch lengths.\n\n\nOn peut alors sauvegarder les résultats dans un fichier au format Newick.\n\nwrite.tree(lx_upgma, \"lx_upgma.nwk\")\n\nOn obtient un arbre unique enraciné qu’on peut facilement visualiser.\n\nplot(lx_upgma)"
  },
  {
    "objectID": "distance.html#neighbour-joining",
    "href": "distance.html#neighbour-joining",
    "title": "\n2  Méthodes par distance\n",
    "section": "\n2.3 Neighbour joining",
    "text": "2.3 Neighbour joining\nLa méthode de neighbour joining est plus sophistiquée que celle de UPGMA mais reste néanmoins simple. Elle s’en distingue par la prise en compte dans l’algorithme de la distance entre toutes les paires de taxons, et non seulement entre les paires les plus proches. Elle produit un arbre non enraciné et non ultramétrique.\n\nlx_nj &lt;- NJ(lx_dist)\nlx_nj\n\n\nPhylogenetic tree with 9 tips and 7 internal nodes.\n\nTip labels:\n  Magenta, Cyan, Jaune, Vert, Violet, Orange, ...\n\nUnrooted; includes branch lengths.\n\nplot(lx_nj, \"unrooted\")\n\n\n\n\nOn peut bien sûr artificiellement enraciner l’arbre, mais c’est rarement une bonne idée. C’est néanmoins parfois nécessaire pour visualiser un grand nombre de langues.\n\nplot(lx_nj, \"tidy\")"
  },
  {
    "objectID": "distance.html#neighbornet",
    "href": "distance.html#neighbornet",
    "title": "\n2  Méthodes par distance\n",
    "section": "\n2.4 NeighborNet",
    "text": "2.4 NeighborNet\nL’algorithme NeighborNet permet d’obtenir non pas un arbre mais un réseau qui montre notamment les conflits dans les données.\n\nlx_nn &lt;- neighborNet(lx_dist)\nlx_nn\n\n\nPhylogenetic tree with 9 tips and 35 internal nodes.\n\nTip labels:\n  Indigo, Rouge, Magenta, Cyan, Bleu, Violet, ...\n\nUnrooted; includes branch lengths.\n\n\n\nplot(lx_nn)"
  },
  {
    "objectID": "parcimonie.html",
    "href": "parcimonie.html",
    "title": "\n3  Méthodes de parcimonie\n",
    "section": "",
    "text": "Contrairement aux méthodes par distance, les méthodes de parcimonie ne construisent pas un arbre pas à pas mais recherchent le ou les arbre optimaux parmi les arbres possibles. Le critère d’évaluation des arbres est celui de maximum de parcimonie: l’arbre préféré est celui qui suppose le moins de changements. Autrement dit, on suppose qu’un changement partagé s’est a priori produit dans l’ancêtre commun plutôt que de manière indépendante dans des langues différentes. Les méthodes de parcimonie cherchent donc à minimiser les homoplasies ou innovations parallèles.\nLes méthodes de parcimonie sont plus complexes que celles par distance mais restent néanmoins beaucoup plus simples que les méthodes probabilistes. Si elles reposent sur peu de suppositions et ont une solide base épistémologique, ces méthodes posent des problèmes statistiques et peuvent donner des résultats faux dans certaines conditions.\nCommençons par importer de nouveau la matrice de traits que nous avions sauvegardée précédemment."
  },
  {
    "objectID": "parcimonie.html#parcimonie-générale",
    "href": "parcimonie.html#parcimonie-générale",
    "title": "\n3  Méthodes de parcimonie\n",
    "section": "\n3.1 Parcimonie générale",
    "text": "3.1 Parcimonie générale\nParmi les différentes variantes de parcimonie, la plus simple autorise tous les changements sans restriction et les traite à égalité sans pondération, orientation, ou ordre. Dans le cas d’une matrice de traits binaires, les changements 0 &gt; 1 et 1 &gt; 0 sont ainsi traités de manière identique, et il n’est pas nécessaire de connaitre l’état ancestral de chaque trait et si un changement constitue une innovation ou une réversion, ce qui implique que le résultat est un arbre non enraciné.\n\n\n\n\n\n\n\n\nÀ faire\n\n\n\nInclure les autres types de parcimonie\n\n\nJusqu’à une dizaine de taxons, il est possible d’utiliser l’algorithme Branch and bound qui garantit de trouver la solution optimale. Le résultat est un objet multiPhylo pouvant contenir plusieurs arbres, bien qu’ici il n’y en ai qu’un seul.\n\n\n\n\n\n\n\n\nÀ faire\n\n\n\nVérifier le traitement des données manquantes\n\n\n\nlx_bab &lt;- bab(lx_phy)\nlx_bab[[1]]\n\n\nPhylogenetic tree with 9 tips and 7 internal nodes.\n\nTip labels:\n  Magenta, Cyan, Indigo, Jaune, Violet, Vert, ...\n\nUnrooted; no branch lengths.\n\nplot(lx_bab[[1]], \"unrooted\")\n\n\n\n\nIl est nécessaire de calculer explicitement la longueur des différentes branches. La fonction acctran() permet de calculer la longueur par la méthode de transformation accélérée qui assigne les changements le plus haut possible dans l’arbre et favorise l’interprétation des homoplasies comme des réversions.\n\nlx_bab &lt;- acctran(lx_bab, lx_phy)\nlx_bab[[1]]\n\n\nPhylogenetic tree with 9 tips and 7 internal nodes.\n\nTip labels:\n  Magenta, Cyan, Indigo, Jaune, Violet, Vert, ...\n\nUnrooted; includes branch lengths.\n\nplot(lx_bab[[1]], \"unrooted\")\n\n\n\n\nOn peut alors sauvegarder les résultats (arbres avec longueurs de branches) dans un fichier au format Newick.\n\nwrite.tree(lx_bab, \"lx_bab.nwk\")\n\nAu-delà d’une dizaine de taxons, il est nécessaire d’utiliser une méthode heuristique comme le Parsimony Ratchet. Ici, la méthode retourne un seul et unique arbre qui diffère de ceux obtenus par la méthode précédente.\n\nlx_pratchet &lt;- pratchet(lx_phy)\nlx_pratchet &lt;- acctran(lx_pratchet, lx_phy)\nwrite.tree(lx_pratchet, \"lx_pratchet.nwk\")\n\n\nplot(lx_pratchet, \"unrooted\")"
  },
  {
    "objectID": "evaluation.html",
    "href": "evaluation.html",
    "title": "\n4  Évaluation\n",
    "section": "",
    "text": "Il est utile d’évaluer la robustesse des résultats obtenus. On peut le faire avec un rééchantillonnage aléatoire avec remise (bootstrap) qui va simuler de la variation et permettre ainsi de quantifier la sensibilité des résultats aux données de l’échantillon observé. Cette méthode permet d’obtenir pour chaque branche de l’arbre la proportion d’arbres rééchantillonnés qui contiennent cette branche et ainsi d’identifier les branches reposant sur un faible nombre de données.\nOn peut par exemple évaluer nos résultats obtenus par UPGMA.\n\nlibrary(tidyverse)\nlibrary(phangorn)\nlx_phy <- read.phyDat(\"lx_phy.txt\",\n  type = \"USER\",\n  levels = c(0, 1)\n)\nlx_upgma <- read.tree(\"lx_upgma.nwk\")\n\nIl faut au préalable récupérer la matrice de données. C’est totalement redondant mais il s’agit d’une contrainte technique. Il faut en plus définir une fonction qui sera appliquée à chaque échantillon, ici on utilise la composition de phyDat(), dist.hamming() puis upgma(). On définit également à l’avance le nombre de rééchantillonages à effectuer, ici 1000.\n\nlibrary(TreeTools)\nlx_m <- PhyDatToMatrix(lx_phy)\nboot_upgma_hamming <- function(x) {\n  upgma(dist.hamming(phyDat(x, type = \"USER\", levels = c(0, 1))))\n}\nn_bs <- 1000\n\nOn peut alors lancer la procédure de rééchantillonage sur l’arbre obtenu par UPGMA et la matrice transposée de données. Même avec 1000 rééchantillonages, obtient les résultats en un temps très court.\n\n\nLa fonction set.seed() permet de fixer la graine aléatoire et d’assurer la reproductibilité des résultats.\n\nset.seed(123456)\nlx_upgma_bs <- boot.phylo(lx_upgma,\n  lx_m,\n  boot_upgma_hamming,\n  B = n_bs,\n  trees = TRUE,\n  quiet = TRUE\n)\n\nOn peut ainsi obtenir le nombre de rééchantillonages où l’un des clades de l’arbre par UPGMA apparaît. Il faut rajouter les valeurs des feuilles (langues), qui par définition apparaissent toujours.\n\nupgma_bs_scores <- prop.clades(lx_upgma, lx_upgma_bs$trees, rooted = TRUE)\nupgma_support <- c(rep(n_bs, length(lx_phy)), upgma_bs_scores)\nupgma_support_pct <- upgma_support / n_bs\n\nOn peut ensuite rajouter les valeurs de bootstrap obtenues sur les différents nœuds internes de l’arbre UPGMA.\n\nlibrary(ggtree)\nggtree(lx_upgma) +\n  geom_tiplab() +\n  geom_nodelab(aes(label = upgma_support_pct), geom = \"text\", hjust = -.1) +\n  xlim_tree(0.14) +\n  theme_tree()\n\n\n\n\nOn peut choisir de n’afficher que les valeurs supérieures à un certain seuil, typiquement 70%.\n\nupgma_support_pct[upgma_support_pct < .7] <- NA\nggtree(lx_upgma) +\n  geom_tiplab() +\n  geom_nodelab(aes(label = upgma_support_pct), geom = \"text\", hjust = -.1) +\n  xlim_tree(0.14) +\n  theme_tree()"
  },
  {
    "objectID": "evaluation.html#résumer-laccord-entre-des-résultats",
    "href": "evaluation.html#résumer-laccord-entre-des-résultats",
    "title": "\n4  Évaluation\n",
    "section": "\n4.2 Résumer l’accord entre des résultats",
    "text": "4.2 Résumer l’accord entre des résultats\nUne analyse phylogénétique résulte souvent non pas en un arbre unique mais en un ensemble d’arbres. C’est le cas par exemple de notre analyse par parcimonie.\n\nlx_bab <- read.tree(\"lx_bab.nwk\")\n\nIl est possible de résumer l’accord entre ces arbres par un arbre consensus qui ne contient que les clades présents dans une proportion p des arbres. Un arbre consensus est donc normalement moins résolu que les arbres obtenus.\nUn arbre consensus strict ne contient que les clades présents dans tous les arbres (p = 1).\n\n\nUn arbre consensus n’a pas en principe de longueurs de branches.\n\nlx_bab_consensus <- consensus(lx_bab, p = 1)\nggtree(lx_bab_consensus, layout = \"daylight\") +\n  geom_tiplab2() +\n    xlim(-4.75, 3.85) + ylim(-4.25, 4.75) +\n  theme_tree()\n\n\n\n\nUn arbre consensus majoritaire contient lui les clades présents dans la majorité (p ≥ .5) des arbres.\n\nlx_bab_consensus_mj <- consensus(lx_bab, p = .5)\nggtree(lx_bab_consensus_mj, layout = \"daylight\") +\n  geom_tiplab2() +\n  xlim(-6, 5) + ylim(-5, 5.25) +\n  theme_tree()\n\n\n\n\n\n\n\n\n\n\nÀ faire\n\n\n\nscore de parcimonie, CI, RI, etc."
  },
  {
    "objectID": "bibliographie.html",
    "href": "bibliographie.html",
    "title": "Bibliographie",
    "section": "",
    "text": "Atkinson, Quentin D. & Russell D. Gray. 2005. Curious parallels and\ncurious connections: Phylogenetic thinking in biology and historical\nlinguistics. Systematic Biology 54(4). 513–526. https://doi.org/10.1080/10635150590950317.\n\n\nAubert, Damien. 2017. Classer le vivant: Les perspectives de la\nsystématique évolutionniste moderne. Paris: Ellipses.\n\n\nBrower, Andrew V. Z. & Randall T. Schuh. 2021. Biological\nsystematics: Principles and applications. 3. edn. Ithaca: Comstock.\n\n\nDarlu, Pierre, Pascal Tassy & René Zaragüeta i Bagils. 2019. La\nreconstruction phylogénétique: Concepts et méthodes. 2. edn. Paris:\nÉditions Matériologiques.\n\n\nDunn, Michael. 2015. Language phylogenies. In Claire Bowern &\nBethwyn Evans (Hrsg.), The Routledge handbook of historical\nlinguistics, 190–211. London: Routledge. https://doi.org/10.4324/9781315794013.\n\n\nFelsenstein, Joseph. 2004. Inferring phylogenies. Sunderland:\nSinauer.\n\n\nGeisler, Hans & Johann-Mattis List. 2013. Do languages grow on\ntrees? The tree metaphor in the history of linguistics. In Heiner\nFangerau, Hans Geisler, Thorsten Halling & William Martin (Hrsg.),\nClassification and evolution in biology, linguistics and the history\nof science, 111–124. Stuttgart: Steiner.\n\n\nGoldstein. 2020. Indo-European phylogenetics with R: A tutorial\nintroduction. Journal of Indo-European Linguistics. https://doi.org/10.1163/22125892-20201000.\n\n\nGregory, T. Ryan. 2008. Understanding evolutionary trees. Evolution:\nEducation and Outreach 1(2). 121–137. https://doi.org/10.1007/s12052-008-0035-x.\n\n\nGrolemund, Garrett. 2014. Hands-on programming with R: Write your\nown functions and simulations. Sebastopol: O’Reilly Media. https://rstudio-education.github.io/hopr/.\n\n\nHervé, Maxime. 2020. Systématique animale: D’Aristote aux\nphylogénies moléculaires. Histoire, concepts et méthodes de la\nclassification. Louvain-la-Neuve: De Boeck Supérieur.\n\n\nJacques, Guillaume & Johann-Mattis List. 2019. Save the trees: Why\nwe need tree models in linguistic reconstruction (and when we should\napply them). Journal of Historical Linguistics 9(1). 128–166.\nhttps://doi.org/10.1075/jhl.17008.mat.\n\n\nLemey, Philippe, Marco Salemi & Anne-Mieke Vandamme (Hrsg.). 2009.\nThe phylogenetic handbook: A practical approach to phylogenetic\nanalysis and hypothesis testing. 2. edn. Cambridge: Cambridge\nUniversity Press. https://doi.org/10.1017/CBO9780511819049.\n\n\nPerrière, Guy & Céline Brochier-Armanet. 2010. Concepts et\nméthodes en phylogénie moléculaire. Paris: Springer.\n\n\nWickham, Hadley & Garrett Grolemund. 2017. R for data science:\nImport, tidy, transform, visualize, and model data. Sebastopol:\nO’Reilly Media. http://r4ds.had.co.nz/.\n\n\nWickham, Hadley & Garrett Grolemund. 2018. R pour les data\nsciences: Importer, classer, transformer, visualiser et modéliser les\ndonnées. Paris: Eyrolles."
  },
  {
    "objectID": "index.html#bienvenue",
    "href": "index.html#bienvenue",
    "title": "Phylolinguistique avec R",
    "section": "Bienvenue",
    "text": "Bienvenue\nCe tutoriel est une introduction à la phylolinguistique, c’est-à-dire aux méthodes phylogénétiques appliquées à la linguistique, à l’aide du logiciel libre R. Le but est d’apprendre à des linguistes à utiliser les méthodes de classification et d’inférence phylogénétique courantes en biologie.\n\n\n\n\n\n\n\n\nVous pouvez visualiser ce site en version sombre à l’aide du bouton  du menu latéral droit.\n\n\n\nEn l’état, il s’agit avant tout d’un pense-bête pour moi-même ainsi que mes collègues et étudiants.\n\n\n\n\n\n\nAvertissement\n\n\n\nCe tutoriel est en construction. Il reste assez basique et, s’il pourra s’étoffer à l’avenir, il ne s’adresse pour l’instant pas aux néophytes complets. Les concepts de base de la linguistique historique et comparative comme de la phylogénétique sont rarement expliqués et le plus souvent présupposés, et il n’y a pas de références systématiques à la littérature scientifique pertinente.\n\n\n\n\n\n\n\n\nParticipez!\n\n\n\nN’hésitez pas à signaler un problème ou bien à faire part de vos commentaires sur Github via le lien du menu latéral gauche.\n\n\n\n\n\n\n\n\nNote technique\n\n\n\nCe tutoriel est réalisé avec Quarto, et le code R utilise le Tidyverse. Le code source est librement accessible sur Github."
  },
  {
    "objectID": "avanttout.html#pourquoi",
    "href": "avanttout.html#pourquoi",
    "title": "Avant tout chose",
    "section": "Pourquoi?",
    "text": "Pourquoi?\nLes linguistes ont pendant longtemps réalisé des classifications phylogénétiques des langues à la main. Toutefois cela devient rapidement impossible avec de larges jeux de données à moins de partir à la «cueillette de cerises» en sélectionnant intentionnellement un petit nombre de données, ce qui est la porte ouverte aux biais de sélection.\nMême pour les méthodes les plus simples, comme la lexicostatistique, qui peuvent être effectuées manuellement, l’analyse des données est longue et fastidieuse, et la moindre modification des données demande de recommencer à zéro. Il s’agit là typiquement d’une tâche pour un ordinateur.\n\n\nPour n taxons, il y a \\(\\frac{(2n-3)!}{2^{n-2}(n-2)!}\\) arbres racinés à embranchements binaires possibles. Pour 10 langues, il y a plus de 34 millions de possibilités.\n\n\n\n\nn\narbres\n\n\n\n2\n1\n\n\n3\n3\n\n\n4\n15\n\n\n5\n105\n\n\n6\n945\n\n\n7\n10395\n\n\n8\n135135\n\n\n9\n2027025\n\n\n10\n34459425\n\n\n20\n8.200795 × 1021\n\n\n\n30\n4.951798 × 1038\n\n\n\n40\n1.009847 × 1057\n\n\n\n50\n2.752921 × 1076\n\n\n\n\n\n\nEn outre, la plupart des méthodes d’inférence phylogénétique compare les différents arbres théoriquement possibles à la recherche du ou des arbres optimaux selon le critère choisi (maximum de parcimonie, de compatibilité, de vraisemblance, de probabilité postérieure). Or le nombre d’arbres à comparer devient vite astronomique en fonction du nombre de taxons (langues), si bien qu’il est le plus souvent impossible de comparer tous les arbres possibles, et il est nécessaire de recourir à des méthodes heuristiques complexes afin de trouver une solution approximative. Il est évidemment impossible de se passer d’un ordinateur pour cela.\nLe logiciel R, en plus d’être libre, gratuit et multi-plateforme, est particulièrement indiqué pour ce genre de travail. Il est spécialisé dans l’analyse quantitative et la visualisation de données, et il existe de nombreuses extensions dédiées à la phylogénétique."
  }
]