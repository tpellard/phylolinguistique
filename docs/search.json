[
  {
    "objectID": "index.html#bienvenue",
    "href": "index.html#bienvenue",
    "title": "Phylolinguistique avec R",
    "section": "Bienvenue",
    "text": "Bienvenue\nCe tutoriel est une introduction à la phylolinguistique, c’est-à-dire aux méthodes phylogénétiques appliquées à la linguistique, à l’aide du logiciel libre R. Le but est d’apprendre à des linguistes à utiliser les méthodes de classification et d’inférence phylogénétique courantes en biologie.\n\n\n\n\n\n\n\n\nVous pouvez visualiser ce site en version sombre à l’aide du bouton  du menu latéral droit.\n\n\n\nEn l’état, il s’agit avant tout d’un pense-bête pour moi-même ainsi que mes collègues et étudiants.\n\n\n\n\n\n\nAvertissement\n\n\n\nCe tutoriel est en construction. Il reste assez basique et, s’il pourra s’étoffer à l’avenir, il ne s’adresse pour l’instant pas aux néophytes complets. Les concepts de base de la linguistique historique et comparative comme de la phylogénétique sont rarement expliqués et le plus souvent présupposés, et il n’y a pas de références systématiques à la littérature scientifique pertinente.\n\n\n\n\n\n\n\n\nParticipez!\n\n\n\nN’hésitez pas à signaler un problème ou bien à faire part de vos commentaires sur Github via le lien du menu latéral gauche.\n\n\n\n\n\n\n\n\nNote technique\n\n\n\nCe tutoriel est réalisé avec Quarto, et le code R utilise le Tidyverse. Le code source est librement accessible sur Github."
  },
  {
    "objectID": "index.html#ressources",
    "href": "index.html#ressources",
    "title": "Phylolinguistique avec R",
    "section": "Ressources",
    "text": "Ressources\nLes ressources ci-dessous sont recommandées pour une (re)mise à niveau ou pour aller plus loin.\n\nPhylogénétique\nEn français, l’introduction à la systématique de Hervé (2020) constitue une bonne porte d’entrée, et Aubert (2017) est un manuel plus complet. On peut également recommander l’article de Gregory (2008) pour éviter les erreurs d’interprétations courantes des arbres phylogénétiques. Le cours en ligne Introduction à la biologie de l’évolution est également à signaler.\nPour aller plus loin, on peut consulter les manuels avancés de Darlu, Tassy & Zaragüeta i Bagils (2019) et Perrière & Brochier-Armanet (2010), ainsi que ceux en anglais de Felsenstein (2004), Lemey, Salemi & Vandamme (2009) et Brower & Schuh (2021).\nVoir aussi les tutoriels:\n\nAn Intro to Phylogenetic Tree Construction in R\nla vignette Estimating phylogenetic trees with phangorn\n\n\n\nLinguistique\nConcernant les applications à la linguistique, Atkinson & Gray (2005), Geisler & List (2013), et Jacques & List (2019) détaillent le transfert de concepts phylogénétiques entre la biologie et la linguistique.\nD’un point de vue pratique et technique, on peut recommander Dunn (2015), ainsi que l’excellent tutoriel en R de Goldstein (2020). Voir aussi le tutoriel Practical phylogenetic methods for linguistic typology.\n\n\nR\nLes manuels de Grolemund (2014) et de Wickham & Grolemund (2017) sont librement disponibles en ligne, et il existe une traduction en français de ce dernier (Wickham & Grolemund 2018).\nIl existe en outre de nombreux tutoriels en ligne, y compris en français, comme:\n\nIntroduction à R et au tidyverse\nBegin’R\nutilitR\nPréparation et manipulation de données dans R\n\n\n\n\n\nAtkinson, Quentin D. & Russell D. Gray. 2005. Curious parallels and curious connections: Phylogenetic thinking in biology and historical linguistics. Systematic Biology 54(4). 513‑526. https://doi.org/10.1080/10635150590950317.\n\n\nAubert, Damien. 2017. Classer le vivant: Les perspectives de la systématique évolutionniste moderne. Paris: Ellipses.\n\n\nBrower, Andrew V. Z. & Randall T. Schuh. 2021. Biological systematics: Principles and applications. 3ᵉ edn. Ithaca: Comstock.\n\n\nDarlu, Pierre, Pascal Tassy & René Zaragüeta i Bagils. 2019. La reconstruction phylogénétique: Concepts et méthodes. 2ᵉ edn. Paris: Éditions Matériologiques.\n\n\nDunn, Michael. 2015. Language phylogenies. In Claire Bowern & Bethwyn Evans (éd.), The Routledge handbook of historical linguistics, 190‑211. London: Routledge. https://doi.org/10.4324/9781315794013.\n\n\nFelsenstein, Joseph. 2004. Inferring phylogenies. Sunderland: Sinauer.\n\n\nGeisler, Hans & Johann-Mattis List. 2013. Do languages grow on trees? The tree metaphor in the history of linguistics. In Heiner Fangerau, Hans Geisler, Thorsten Halling & William Martin (éd.), Classification and evolution in biology, linguistics and the history of science, 111‑124. Stuttgart: Steiner.\n\n\nGoldstein. 2020. Indo-European phylogenetics with R: A tutorial introduction. Journal of Indo-European Linguistics. https://doi.org/10.1163/22125892-20201000.\n\n\nGregory, T. Ryan. 2008. Understanding evolutionary trees. Evolution: Education and Outreach 1(2). 121‑137. https://doi.org/10.1007/s12052-008-0035-x.\n\n\nGrolemund, Garrett. 2014. Hands-on programming with R: Write your own functions and simulations. Sebastopol: O’Reilly Media. https://rstudio-education.github.io/hopr/.\n\n\nHervé, Maxime. 2020. Systématique animale: D’Aristote aux phylogénies moléculaires. Histoire, concepts et méthodes de la classification. Louvain-la-Neuve: De Boeck Supérieur.\n\n\nJacques, Guillaume & Johann-Mattis List. 2019. Save the trees: Why we need tree models in linguistic reconstruction (and when we should apply them). Journal of Historical Linguistics 9(1). 128‑166. https://doi.org/10.1075/jhl.17008.mat.\n\n\nLemey, Philippe, Marco Salemi & Anne-Mieke Vandamme (éd.). 2009. The phylogenetic handbook: A practical approach to phylogenetic analysis and hypothesis testing. 2ᵉ edn. Cambridge: Cambridge University Press. https://doi.org/10.1017/CBO9780511819049.\n\n\nPerrière, Guy & Céline Brochier-Armanet. 2010. Concepts et méthodes en phylogénie moléculaire. Paris: Springer.\n\n\nWickham, Hadley & Garrett Grolemund. 2017. R for data science: Import, tidy, transform, visualize, and model data. Sebastopol: O’Reilly Media. http://r4ds.had.co.nz/.\n\n\nWickham, Hadley & Garrett Grolemund. 2018. R pour les data sciences: Importer, classer, transformer, visualiser et modéliser les données. Paris: Eyrolles."
  },
  {
    "objectID": "avanttout.html#pourquoi",
    "href": "avanttout.html#pourquoi",
    "title": "Avant tout chose",
    "section": "Pourquoi?",
    "text": "Pourquoi?\nLes linguistes ont pendant longtemps réalisé des classifications phylogénétiques des langues à la main. Toutefois cela devient rapidement impossible avec de larges jeux de données à moins de partir à la «cueillette de cerises» en sélectionnant intentionnellement un petit nombre de données, ce qui est la porte ouverte aux biais de sélection.\nMême pour les méthodes les plus simples, comme la lexicostatistique, qui peuvent être effectuées manuellement, l’analyse des données est longue et fastidieuse, et la moindre modification des données demande de recommencer à zéro. Il s’agit là typiquement d’une tâche pour un ordinateur.\n\n\n\n\n\n\n\n\nPour n taxons, il y a \\(\\frac{(2n-3)!}{2^{n-2}(n-2)!}\\) arbres racinés à embranchements binaires possibles. Pour 10 langues, il y a plus de 34 millions de possibilités.\n\n\n\n\nn\narbres\n\n\n\n2\n1\n\n\n3\n3\n\n\n4\n15\n\n\n5\n105\n\n\n6\n945\n\n\n7\n10395\n\n\n8\n135135\n\n\n9\n2027025\n\n\n10\n34459425\n\n\n20\n8.200795 × 1021\n\n\n\n30\n4.951798 × 1038\n\n\n\n40\n1.009847 × 1057\n\n\n\n50\n2.752921 × 1076\n\n\n\n\n\n\n\n\n\nEn outre, la plupart des méthodes d’inférence phylogénétique compare les différents arbres théoriquement possibles à la recherche du ou des arbres optimaux selon le critère choisi (maximum de parcimonie, de compatibilité, de vraisemblance, de probabilité postérieure). Or le nombre d’arbres à comparer devient vite astronomique en fonction du nombre de taxons (langues), si bien qu’il est le plus souvent impossible de comparer tous les arbres possibles, et il est nécessaire de recourir à des méthodes heuristiques complexes afin de trouver une solution approximative. Il est évidemment impossible de se passer d’un ordinateur pour cela.\nLe logiciel R, en plus d’être libre, gratuit et multiplateforme, est particulièrement indiqué pour ce genre de travail. Il est spécialisé dans l’analyse quantitative et la visualisation de données, et il existe de nombreuses extensions dédiées à la phylogénétique.\n\n\n\n\n\n\nAvertissement\n\n\n\nLe logiciel R n’est cependant pas l’outil de choix pour effectuer des inférences phylogénétiques. Seules les méthodes les plus simples sont implémentées, et il est normalement nécessaire d’utiliser d’autres outils. C’est notamment des méthodes bayésiennes qui sont à l’heure actuelle les plus couramment utilisées.\nEn revanche, R est un outil de choix pour l’analyse des résultats d’inférence phylogénétique obtenus avec d’autres outils."
  },
  {
    "objectID": "avanttout.html#installation-des-logiciels",
    "href": "avanttout.html#installation-des-logiciels",
    "title": "Avant tout chose",
    "section": "Installation des logiciels",
    "text": "Installation des logiciels\nIl est nécessaire avant toute chose d’installer le logiciel R si ce n’est pas déjà fait: https://cran.r-project.org/.\n\n\n\n\n\n\nL’utilisation de l’environnement de développement gratuit, libre et multiplateforme Rstudio est recommandée.\n\n\n\nIl est également nécessaire d’installer un certain nombre d’extensions R. Il suffit pour cela de saisir les commandes suivantes dans la console R.\n\ninstall.packages(\"tidyverse\")\ninstall.packages(\"ape\")\ninstall.packages(\"phangorn\")\ninstall.packages(\"TreeTools\")\n\nLes extensions ggtree et tanggle pour la visualisation avancée des arbres phylogénétiques nécessitent au préalable d’installer BiocManager.\n\ninstall.packages(\"BiocManager\")\nBiocManager::install(\"ggtree\")\nBiocManager::install(\"tanggle\")"
  },
  {
    "objectID": "import.html#import",
    "href": "import.html#import",
    "title": "\n1  Préparation des données\n",
    "section": "\n1.1 Import",
    "text": "1.1 Import\nEdictor permet de sauvegarder les données traitées sous forme d’un fichier tabulaire au format .tsv. Il est alors très simple de l’importer avec R, en prenant garde d’ignorer les lignes de commentaires à la fin marquées par #.\nTéléchargeons et importons pour l’exemple des données sur les variétés bai fournies dans Edictor. Les seules colonnes qui vont nous intéresser ici sont CONCEPTID (identifiant unique du concept), DOCULECT (langue) et COGIDS (classe de cognats). En outre, certaines langues peuvent avoir plusieurs formes (variantes?) pour une même classe de cognats, mais l’information qui nous intéresse est simplement la présence ou non d’un cognat, on peut donc supprimer les lignes superflues correspondantes avec la fonction distinct().\n\nlibrary(tidyverse)\nurl &lt;- \"https://raw.githubusercontent.com/digling/edictor/master/data/BAI.tsv\"\ndownload.file(url, \"BAI.tsv\")\nlx_orig &lt;- read_tsv(\"BAI.tsv\", comment = \"#\")\nlx &lt;- lx_orig %&gt;%\n  select(CONCEPTID, DOCULECT, COGIDS) %&gt;% \n  distinct()\n\nL’information sur les classes de cognats se trouve dans la colonne COGIDS.\n\n\n\n\n  \n\n\n\nComme il s’agit de faire un exemple et non une réelle analyse phylogénétique, je propose de renommer les langues de manière arbitraire afin de ne pas induire en erreur les personnes qui tomberaient par hasard sur les résultats de nos analyses et les diffuseraient sans le contexte de ce tutoriel.\n\nlx &lt;- lx %&gt;%\n  mutate(DOCULECT = case_when(\n    DOCULECT == \"Gongxing\" ~ \"Magenta\",\n    DOCULECT == \"Jinman\" ~ \"Cyan\",\n    DOCULECT == \"Mazhelong\" ~ \"Jaune\",\n    DOCULECT == \"Dashi\" ~ \"Vert\",\n    DOCULECT == \"Zhoucheng\" ~ \"Violet\",\n    DOCULECT == \"Jinxing\" ~ \"Orange\",\n    DOCULECT == \"Tuolo\" ~ \"Rouge\",\n    DOCULECT == \"Enqi\" ~ \"Bleu\",\n    DOCULECT == \"Ega\" ~ \"Indigo\",\n  ))"
  },
  {
    "objectID": "import.html#conversion",
    "href": "import.html#conversion",
    "title": "\n1  Préparation des données\n",
    "section": "\n1.2 Conversion",
    "text": "1.2 Conversion\nLe but est de construire une matrice indiquant quels mots sont cognats, mais plusieurs types de matrices sont possibles.\n\n1.2.1 États multiples\nTout d’abord, on peut utiliser un codage à états multiples et encoder pour chaque concept quelle est la classe de cognat de la forme de chaque langue. Chaque caractère peut ainsi avoir dans une langue une valeur parmi un ensemble d’une longueur finie, typiquement représentée par un chiffre entre 0 et 9 dans les formats de fichier pour la phylogénétique. L’ensemble des états possibles est propre à chaque caractère: 1 pour un caractère ne représente pas la même valeur que 1 pour un autre caractère, et des caractères différents peuvent ne pas avoir le même nombre d’états possibles.\n\n\n\n\n\n\n\n\nAu-delà de 10 états différents, il est nécessaire d’utiliser d’autres symboles comme des lettres car les chaque doit être représenté par un seul symbole.\n\n\n\nUn problème qui se pose pour le codage à états multiples est celui du polymorphisme, par exemple quand une langue présente deux synonymes pour un même concept et que chacun appartient à une classe de cognat différente. La convention standard pour une langue présentant à la fois l’état 1 et l’état 2 sera ici de noter dans ce cas {12}.\n\n\n\n\n\n\n\n\nOn trouve aussi la convention d’utiliser des parenthèses.\n\n\n\n\n\n\n\n\n\n\nVérifier s’il est possible d’avoir un polymorphisme de plus de deux états.\n\n\n\n\nIl donc nécessaire tout d’abord de transformer les valeurs de COGIDS en chiffres à l’intérieur de chaque groupe de CONCEPTID. On concatène ensuite les valeurs multiples de COGIDS pour un même DOCULECT et CONCEPTID, avant de les entourer de parenthèses. On peut ensuite pivoter (et non transposer) notre tableau: les valeurs de CONCEPTID vont devenir des colonnes remplies par les valeurs correspondantes de COGIDS. Si pour une valeur de CONCEPTID donnée il n’y a pas de COGIDS associé dans un DOCULECT, c’est-à-dire que la langue n’a aucun concept avec une forme appartenant à cette classe de cognat, on remplit la cellule avec un ? pour indiquer que les données sont manquantes\n\nlx_multi &lt;- lx %&gt;%\n  group_by(CONCEPTID) %&gt;%\n  mutate(COGIDS = as.factor(COGIDS) %&gt;% as.numeric()) %&gt;%\n  group_by(DOCULECT, CONCEPTID) %&gt;%\n  summarise(COGIDS = paste0(COGIDS, collapse = \"\")) %&gt;%\n  ungroup() %&gt;%\n  mutate(COGIDS = ifelse(str_detect(COGIDS, \"..+\"), paste0(\"{\", COGIDS, \"}\"), COGIDS)) %&gt;%\n  pivot_wider(\n    names_from = CONCEPTID,\n    values_from = COGIDS,\n    values_fill = \"?\",\n  )\n\n\n\n\n\n  \n\n\n\nPour finir de convertir nos données en une matrice phylogénétique prête à l’analyse, il suffit de les convertir en objet matriciel puis enfin d’utiliser la fonction MatrixTophyDat() de TreeTools.\n\n\n\n\n\n\n\n\nLa fonction phyDat() de phangorn ne semble pas capable de convertir les cas de polymorphismes.\n\n\n\n\nlibrary(TreeTools)\nlx_phy_multi &lt;- lx_multi %&gt;%\n  column_to_rownames(\"DOCULECT\") %&gt;%\n  as.matrix() %&gt;%\n  MatrixToPhyDat()\n\n\n\n\n\n\n\n\n\nÀ faire\n\n\n\nLe résultat s’affiche mal en HTML.\n\n\nOn peut alors sauvegarder la matrice obtenue avec la fonction write.phyDat(). Plusieurs formats courants comme Nexus ou Phylip sont possibles. Le format Nexus est ici recommandé pour bien prendre en compte les polymorphismes.\n\nlibrary(phangorn)\nwrite.phyDat(lx_phy_multi, \"lx_phy_multi.nex\", format = \"nexus\")\n\nCette conversion étant un peu fastidieuse, il est plus pratique de créer une fonction réutilisable pour tout le processus de conversion d’un fichier .tsvau format Edictor vers une matrice de traits binaires au format phyDat.\n\nas_phyDatM_edictor &lt;- function(dt) {\n  dt %&gt;%\n    group_by(CONCEPTID) %&gt;%\n    mutate(COGIDS = as.factor(COGIDS) %&gt;% as.numeric()) %&gt;%\n    group_by(DOCULECT, CONCEPTID) %&gt;%\n    summarise(COGIDS = paste0(COGIDS, collapse = \"\")) %&gt;%\n    ungroup() %&gt;%\n    mutate(COGIDS = ifelse(str_detect(COGIDS, \"..+\"), paste0(\"{\", COGIDS, \"}\"), COGIDS)) %&gt;%\n    pivot_wider(\n      names_from = CONCEPTID,\n      values_from = COGIDS,\n      values_fill = \"?\",\n    ) %&gt;%\n    column_to_rownames(\"DOCULECT\") %&gt;%\n    as.matrix() %&gt;%\n    MatrixToPhyDat()\n}\n\n\nas_phyDatM_edictor(lx)\n\n9 sequences with 110 character and 43 different site patterns.\nThe states are 1 2 3 4 5 6 7 \n\n\n\n1.2.2 États binaires\nIl est cependant courant en phylolinguistique d’utiliser une matrice avec des caractères binaires: la langue possède-t-elle (1) ou non (0) un cognat pour une classe de cognats et un concept donnés? Cela permet de traiter sans problème les cas de polymorphisme, comme on peut en trouver dans nos données d’exemple, et lève toute limite au nombre d’états possibles pour un caractère. Les méthodes bayésiennes utilisent en général des données binaires car elles modélisent la perte et l’apparition de traits.\nLa conversion est un peu plus complexe et nécessite de pivoter trois fois notre tableau en faisant attention aux éventuelles données manquantes (les cas où un concept n’apparaît pas dans dans la liste d’une langue). Dans un premier temps, on utilise les valeurs de DOCULECT comme noms de colonnes et on remplit de 0 si la langue n’a pas de forme pour une classe de cognat et un concept donnés, et avec 1 sinon. Il faut rajouter une colonne fantoche auparavant avec par exemple rowid_to_column afin de conserver les colonnes CONCEPT et COGIDS et utiliser cette colonne fantoche pour remplir les cellules. On repivote ensuite notre tableau dans l’autre sens en mettant l’information binaire (présence ou non d’une même association entre un concept et une classe de cognat) dans une colonne VALUE dont on convertit le type de numérique à caractère. Pour chaque langue et concept, s’il n’y aucune classe de cognat et donc uniquement des 0 dans VALUE, c’est que les données sont manquantes, et on remplace les 0 par ?, le symbole standard pour les données manquantes. Enfin on peut pivoter à nouveau le tableau, cette fois-ci en utilisant une nouvelle valeur concaténant CONCEPT et COGIDS comme noms de colonnes et en abandonnant ces deux colonnes d’origine. On obtient ainsi un tableau au format large avec les langues (taxons) en lignes et les combinaisons entre concepts et classes de cognats en colonnes, avec 1 pour «présence», 0 pour «absence», et ? pour «donnée manquante».\n\nlx_bin &lt;- lx %&gt;%\n  rowid_to_column() %&gt;%\n  pivot_wider(\n    names_from = DOCULECT,\n    values_from = rowid,\n    values_fill = 0,\n    values_fn = length\n  ) %&gt;%\n  pivot_longer(cols = !(CONCEPTID | COGIDS), names_to = \"DOCULECT\", values_to = \"VALUE\") %&gt;%\n  mutate(VALUE = as.character(VALUE)) %&gt;%\n  group_by(CONCEPTID, DOCULECT) %&gt;%\n  mutate(VALUE = ifelse(sum(VALUE != \"0\") == 0, \"?\", VALUE)) %&gt;%\n  ungroup() %&gt;%\n  mutate(id = paste0(CONCEPTID, \"_\", COGIDS)) %&gt;%\n  select(DOCULECT, id, VALUE) %&gt;%\n  pivot_wider(\n    names_from = id,\n    values_from = VALUE\n  )\n\n\n\n\n\n  \n\n\n\nComme précédemment, il suffit de convertir le résultat avec MatrixTophyDat() de TreeTools.\n\nlx_phy_bin &lt;- lx_bin %&gt;%\n  column_to_rownames(\"DOCULECT\") %&gt;%\n  as.matrix() %&gt;%\n  MatrixToPhyDat()\nlx_phy_bin\n\n9 sequences with 205 character and 31 different site patterns.\nThe states are 0 1 \n\n\nOn peut alors sauvegarder la matrice obtenue avec la fonction write.phyDat(). Plusieurs formats courants comme Nexus ou Phylip sont possibles. Pour une simple matrice comme la nôtre, l’option par défaut (Phylip) est suffisante (le réimport d’un fichier nexus à traits binaires pose en autre des problèmes non encore résolus).\n\nwrite.phyDat(lx_phy_bin, \"lx_phy_bin.nex\", format = \"nexus\")\n\n\n\n\n\n\n\n\n\nÀ faire\n\n\n\nRégler le problème de spécification des symboles dans les fichiers Nexus pour les données binaires.\n\n\nCette conversion étant un peu fastidieuse, il est plus pratique de créer une fonction réutilisable pour tout le processus de conversion d’un fichier .tsvau format Edictor vers une matrice de traits binaires au format phyDat.\n\nas_phyDat2_edictor &lt;- function(dt) {\n  dt %&gt;%\n    rowid_to_column() %&gt;%\n    pivot_wider(\n      names_from = DOCULECT,\n      values_from = rowid,\n      values_fill = 0,\n      values_fn = length\n    ) %&gt;%\n    pivot_longer(cols = !(CONCEPTID | COGIDS), names_to = \"DOCULECT\", values_to = \"VALUE\") %&gt;%\n    mutate(VALUE = as.character(VALUE)) %&gt;%\n    group_by(CONCEPTID, DOCULECT) %&gt;%\n    mutate(VALUE = ifelse(sum(VALUE != \"0\") == 0, \"?\", VALUE)) %&gt;%\n    ungroup() %&gt;%\n    mutate(id = paste0(CONCEPTID, \"_\", COGIDS)) %&gt;%\n    select(DOCULECT, id, VALUE) %&gt;%\n    pivot_wider(\n      names_from = id,\n      values_from = VALUE\n    ) %&gt;%\n    column_to_rownames(\"DOCULECT\") %&gt;%\n    as.matrix() %&gt;%\n    MatrixToPhyDat()\n}\n\n\nas_phyDat2_edictor(lx)\n\n9 sequences with 205 character and 31 different site patterns.\nThe states are 0 1"
  },
  {
    "objectID": "distance.html#calcul-des-distances",
    "href": "distance.html#calcul-des-distances",
    "title": "\n2  Méthodes par distance\n",
    "section": "\n2.1 Calcul des distances",
    "text": "2.1 Calcul des distances\nCommençons par importer de nouveau la matrice de traits à états multiples que nous avions sauvegardée précédemment. Calculer la distance sur les données binarisées pourrait biaiser les calculs en donnant plus de poids aux caractères ayant un plus grand nombre d’états possibles.\n\nlibrary(tidyverse)\nlibrary(phangorn)\nlibrary(TreeTools)\nlx_phy &lt;- ReadAsPhyDat(\"lx_phy_multi.nex\")\n\nIl est trivial de calculer la distance observée, ou p-distance, sur une telle matrice. Il suffit de calculer pour chaque paire de langues le rapport entre nombre de caractères différents et le nombre de caractères total avec la fonction Hamming() qui prend en charge les données manquantes et les polymorphismes.\n\nlx_dist &lt;- Hamming(lx_phy)\n\nLa diagonale des distances de chaque langue avec elle-même est bien sûr 0, et la matrice de distance est symétrique, on peut donc se passer d’afficher l’un des deux triangles.\n\nCodelx_dist_m &lt;- as.matrix(lx_dist)\nlx_dist_m[upper.tri(lx_dist_m)] &lt;- NA\noptions(knitr.kable.NA = \"\")\nknitr::kable(lx_dist_m, digits = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBleu\nCyan\nIndigo\nJaune\nMagenta\nOrange\nRouge\nVert\nViolet\n\n\n\nBleu\n0.00\n\n\n\n\n\n\n\n\n\n\nCyan\n0.13\n0.00\n\n\n\n\n\n\n\n\n\nIndigo\n0.13\n0.08\n0.00\n\n\n\n\n\n\n\n\nJaune\n0.22\n0.21\n0.21\n0.00\n\n\n\n\n\n\n\nMagenta\n0.17\n0.17\n0.18\n0.25\n0.00\n\n\n\n\n\n\nOrange\n0.14\n0.20\n0.21\n0.16\n0.19\n0.00\n\n\n\n\n\nRouge\n0.16\n0.19\n0.17\n0.25\n0.15\n0.20\n0.00\n\n\n\n\nVert\n0.19\n0.22\n0.24\n0.19\n0.20\n0.10\n0.21\n0.00\n\n\n\nViolet\n0.17\n0.20\n0.22\n0.22\n0.23\n0.12\n0.21\n0.14\n0\n\n\n\n\n\nOn peut alternativement afficher la matrice des similitudes en retranchant les distances de 1, voir des pourcentages en multipliant le résultat par 100. On obtient alors une matrice semblable à ce qu’on voit en lexicostatistique.\n\nlx_sim_m &lt;- (1 - as.matrix(lx_dist)) * 100\n\n\nCodelx_sim_m[upper.tri(lx_sim_m)] &lt;- NA\noptions(knitr.kable.NA = \"\")\nknitr::kable(lx_sim_m, digits = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBleu\nCyan\nIndigo\nJaune\nMagenta\nOrange\nRouge\nVert\nViolet\n\n\n\nBleu\n100.00\n\n\n\n\n\n\n\n\n\n\nCyan\n86.92\n100.00\n\n\n\n\n\n\n\n\n\nIndigo\n87.16\n91.67\n100.00\n\n\n\n\n\n\n\n\nJaune\n77.98\n78.70\n79.09\n100.00\n\n\n\n\n\n\n\nMagenta\n83.49\n83.18\n81.65\n75.23\n100.00\n\n\n\n\n\n\nOrange\n86.24\n79.63\n79.09\n83.64\n80.73\n100.00\n\n\n\n\n\nRouge\n84.40\n80.56\n82.73\n75.45\n85.32\n80.00\n100.00\n\n\n\n\nVert\n81.48\n77.57\n76.15\n80.73\n79.63\n89.91\n78.90\n100.00\n\n\n\nViolet\n83.49\n79.63\n78.18\n78.18\n77.06\n88.18\n79.09\n86.24\n100"
  },
  {
    "objectID": "distance.html#sec-upgma",
    "href": "distance.html#sec-upgma",
    "title": "\n2  Méthodes par distance\n",
    "section": "\n2.2 UPGMA",
    "text": "2.2 UPGMA\nL’algorithme de classification UPGMA (Unweighted pair group method with arithmetic mean) est le plus basique et le moins bon pour les classifications génétiques. Cette méthode présuppose notamment une «horloge moléculaire», c’est-à-dire que la vitesse de changement était constante, ce qui est faux en biologie comme en linguistique. Le résultat est un arbre dit ultramétrique où toutes les langues sont alignées au lieu d’être placées en fonction du nombre de changements avec des branches de longueur variées.\nNéanmoins cette méthode est simplissime: on groupe les taxons les plus proches ensemble, et la distance du groupe obtenu aux taxons restants est recalculée en faisant la moyenne des distances des éléments groupés, et on recommence jusqu’à n’avoir plus que deux groupes.\n\nlx_upgma &lt;- upgma(lx_dist)\nlx_upgma\n\n\nPhylogenetic tree with 9 tips and 8 internal nodes.\n\nTip labels:\n  Bleu, Cyan, Indigo, Jaune, Magenta, Orange, ...\n\nRooted; includes branch lengths.\n\n\nOn peut alors sauvegarder les résultats dans un fichier au format Newick.\n\nwrite.tree(lx_upgma, \"lx_upgma.tree\")\n\nOn obtient un arbre unique enraciné qu’on peut facilement visualiser.\n\nplot(lx_upgma)"
  },
  {
    "objectID": "distance.html#neighbour-joining",
    "href": "distance.html#neighbour-joining",
    "title": "\n2  Méthodes par distance\n",
    "section": "\n2.3 Neighbour joining",
    "text": "2.3 Neighbour joining\nLa méthode de neighbour joining est plus sophistiquée que celle de UPGMA mais reste néanmoins simple. Elle s’en distingue par la prise en compte dans l’algorithme de la distance entre toutes les paires de taxons, et non seulement entre les paires les plus proches. Elle produit un arbre non enraciné et non ultramétrique.\n\nlx_nj &lt;- NJ(lx_dist)\nlx_nj\n\n\nPhylogenetic tree with 9 tips and 7 internal nodes.\n\nTip labels:\n  Bleu, Cyan, Indigo, Jaune, Magenta, Orange, ...\n\nUnrooted; includes branch lengths.\n\nplot(lx_nj, \"unrooted\")\n\n\n\n\nOn peut bien sûr artificiellement enraciner l’arbre, mais c’est rarement une bonne idée. C’est néanmoins parfois nécessaire pour visualiser un grand nombre de langues.\n\nplot(lx_nj, \"tidy\")"
  },
  {
    "objectID": "distance.html#neighbornet",
    "href": "distance.html#neighbornet",
    "title": "\n2  Méthodes par distance\n",
    "section": "\n2.4 NeighborNet",
    "text": "2.4 NeighborNet\nL’algorithme NeighborNet permet d’obtenir non pas un arbre mais un réseau qui montre notamment les conflits dans les données.\n\nlx_nn &lt;- neighborNet(lx_dist)\nlx_nn\n\n\nPhylogenetic tree with 9 tips and 45 internal nodes.\n\nTip labels:\n  Orange, Jaune, Bleu, Indigo, Cyan, Magenta, ...\n\nUnrooted; includes branch lengths.\n\n\n\nplot(lx_nn)\n\n\n\n\nCe réseau peut être sauvegardé au format nexus avec la fonction write.nexus.networx().\n\nwrite.nexus.networx(lx_nn, \"lx_nn.nex\")"
  },
  {
    "objectID": "parcimonie.html",
    "href": "parcimonie.html",
    "title": "\n3  Méthodes de parcimonie\n",
    "section": "",
    "text": "Contrairement aux méthodes par distance, les méthodes de parcimonie ne construisent pas un arbre pas à pas mais recherchent le ou les arbre optimaux parmi l’ensemble des arbres possibles. Le critère d’évaluation des arbres est celui de maximum de parcimonie: l’arbre préféré est celui qui suppose le moins de changements. Autrement dit, on suppose qu’un changement partagé s’est a priori produit dans l’ancêtre commun plutôt que de manière indépendante dans des langues différentes. Les méthodes de parcimonie cherchent donc à minimiser les homoplasies ou innovations parallèles.\nLes méthodes de parcimonie sont plus complexes que celles par distance, mais elles restent néanmoins beaucoup plus simples que les méthodes probabilistes. Si elles reposent sur peu de suppositions et ont une solide base épistémologique, ces méthodes posent des problèmes statistiques et peuvent donner des résultats faux dans certaines conditions.\nCommençons par importer de nouveau la matrice de traits à états multiples que nous avions sauvegardée précédemment.\n\nlibrary(tidyverse)\nlibrary(phangorn)\nlibrary(TreeTools)\nlx_phy &lt;- ReadAsPhyDat(\"lx_phy_multi.nex\")\n\nParmi les différentes variantes de parcimonie, la plus simple (dite «de Wagner») autorise tous les changements sans restriction et les traite à égalité sans pondération, orientation, ou ordre. Dans le cas d’une matrice de traits binaires, les changements 0 &gt; 1 et 1 &gt; 0 sont ainsi traités de manière identique, et il n’est pas nécessaire de connaitre l’état ancestral de chaque trait et si un changement constitue une innovation ou une réversion, ce qui implique que le résultat est un arbre non enraciné.\n\n\n\n\n\n\n\n\nÀ faire\n\n\n\nInclure les autres types de parcimonie.\n\n\nLa comparaison des arbres possibles à la recherche du plus parcimonieux est une procédure longue, et avec beaucoup de taxons, il est nécessaire d’utiliser une méthode heuristique comme le Parsimony Ratchet avec pratchet(). Le résultat est un objet multiPhylo pouvant contenir plusieurs arbres si l’on a précisé l’option all = TRUE, bien qu’ici il n’y en ait qu’un seul.\n\n\n\n\n\n\n\n\nÀ faire\n\n\n\nVérifier le traitement des données manquantes et celui des polymorphismes pour les données à états multiples.\n\n\n\nlx_pratchet &lt;- pratchet(lx_phy, trace = 0, method = \"sankoff\", all = TRUE)\nlx_pratchet\n\n\nPhylogenetic tree with 9 tips and 7 internal nodes.\n\nTip labels:\n  Bleu, Magenta, Rouge, Jaune, Orange, Vert, ...\nNode labels:\n  1, 0.67, 1, 1, 1, 0.78, ...\n\nUnrooted; no branch lengths.\n\nplot(lx_pratchet, \"unrooted\")\n\n\n\n\n\n\n\n\n\n\n\n\nL’option trace permet de choisir la quantité d’information à afficher concernant la recherche de l’arbre.\n\n\n\n\n\n\n\n\n\nL’option method = \"sankoff\" permet d’utiliser l’algorithme de Sankoff qui est plus complexe mais plus général également.\n\n\n\nIl est nécessaire de calculer explicitement la longueur des différentes branches. La fonction acctran() permet de calculer la longueur par la méthode de transformation accélérée qui assigne les changements le plus haut possible dans l’arbre et favorise l’interprétation des homoplasies comme des réversions.\n\nlx_pratchet &lt;- acctran(lx_pratchet, lx_phy)\nlx_pratchet\n\n\nPhylogenetic tree with 9 tips and 7 internal nodes.\n\nTip labels:\n  Bleu, Magenta, Rouge, Jaune, Orange, Vert, ...\nNode labels:\n  1, 0.67, 1, 1, 1, 0.78, ...\n\nUnrooted; includes branch lengths.\n\nplot(lx_pratchet, \"unrooted\")\n\n\n\n\nOn peut ensuite enraciner l’arbre, par exemple avec midpoint(), qui place la racine à mi-chemin des deux taxons les plus divergents. Cette méthode présuppose cependant que l’évolution a lieu a taux constant et que la topologie est équilibrée (les taxons sont bien distribués entre les différents clades).\n\nplot(midpoint(lx_pratchet))\n\n\n\n\nUne autre méthode nécessite de déterminer un extra-groupe ou groupe externe (outgroup). La fonction root() permet de procéder à l’enracinement en indiquant le numéro ou le nom du taxon constituant le groupe externe, par exemple «Violet». Cela présuppose bien sûr qu’il ait été inclus dans l’analyse de départ.\n\nlx_pratchet &lt;- root(lx_pratchet, \"Violet\", resolve.root = TRUE)\nplot(lx_pratchet)\n\n\n\n\nS’il n’y a pas de groupe externe mais que l’on connaît les états ancestraux, on peut rajouter aux données un taxon fictif possédant l’état ancestral pour tous les caractères, par exemple 1 partout. On obtient plusieurs arbres cette fois-ci, et chacun est manipulable en utilisant son index numérique.\n\nlx_phy2 &lt;- lx_phy %&gt;% \n  PhyDatToMatrix() %&gt;% \n  rbind(\"Fictif\" = rep(\"1\", ncol(.))) %&gt;% \n  MatrixToPhyDat()\nlx_pratchet &lt;- pratchet(lx_phy2, trace = 0, method = \"sankoff\", all = TRUE) %&gt;% \n  acctran(lx_phy2) %&gt;% \n  root(\"Fictif\", resolve.root = TRUE)\nlx_pratchet\n\n4 phylogenetic trees\n\nlx_pratchet[[1]]\n\n\nPhylogenetic tree with 10 tips and 9 internal nodes.\n\nTip labels:\n  Bleu, Magenta, Rouge, Jaune, Orange, Vert, ...\nNode labels:\n  Root, 1, 0.86, 0.97, 0.97, 0.9, ...\n\nRooted; includes branch lengths.\n\nplot(lx_pratchet)\n\n\n\n\n\n\n\n\n\n\n\n\n\nIl suffit ensuite de supprimer le taxon fictif de l’arbre.\n\nlx_pratchet &lt;- drop.tip(lx_pratchet, \"Fictif\")\nplot(lx_pratchet)\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn peut alors sauvegarder les résultats (arbres avec longueurs de branches) dans un fichier au format Newick. Sauvegardons le résultat également comme un objet R, afin de conserver des propriétés intéressantes pour plus tard.\n\nwrite.tree(lx_pratchet, \"lx_pratchet.tree\")\nwrite_rds(lx_pratchet, \"lx_pratchet.rds\")"
  },
  {
    "objectID": "evaluation.html#évaluation-de-la-stabilité-des-clades",
    "href": "evaluation.html#évaluation-de-la-stabilité-des-clades",
    "title": "\n4  Évaluation des résultats\n",
    "section": "\n4.1 Évaluation de la stabilité des clades",
    "text": "4.1 Évaluation de la stabilité des clades\nIl est utile d’évaluer la stabilité des clades obtenus. On peut le faire avec un ré-échantillonnage aléatoire avec remise (bootstrap) qui va simuler de la variation et permettre ainsi de quantifier la sensibilité des résultats aux données de l’échantillon observé. Cette méthode permet d’obtenir pour chaque branche de l’arbre la proportion d’arbres ré-échantillonnés qui contiennent cette branche et ainsi d’identifier les branches reposant sur un faible nombre de données.\nOn peut par exemple évaluer nos résultats obtenus par UPGMA.\n\nlibrary(tidyverse)\nlibrary(phangorn)\nlibrary(TreeTools)\nlx_phy &lt;- ReadAsPhyDat(\"lx_phy_multi.nex\")\nlx_upgma &lt;- read.tree(\"lx_upgma.tree\")\n\nIl faut au préalable récupérer la matrice de données. C’est totalement redondant mais il s’agit d’une contrainte technique. Il faut en plus définir une fonction qui sera appliquée à chaque échantillon, ici on utilise la composition de MatrixTophyDat(), Hamming() puis upgma(). On définit également à l’avance le nombre de ré-échantillonnages à effectuer, ici 1000.\n\nlx_m &lt;- PhyDatToMatrix(lx_phy)\nboot_upgma_hamming &lt;- function(x) {\n  upgma(Hamming(MatrixToPhyDat(x)))\n}\nn_bs &lt;- 1000\n\nOn peut alors lancer la procédure de ré-échantillonnage sur l’arbre obtenu par UPGMA et la matrice de données. Même avec 1000 ré-échantillonnages, on obtient les résultats en un temps très court.\n\n\nLa fonction set.seed() permet de fixer la graine aléatoire et d’assurer la reproductibilité des résultats.\n\nset.seed(123456)\nlx_upgma_bs &lt;- boot.phylo(lx_upgma,\n  lx_m,\n  boot_upgma_hamming,\n  B = n_bs,\n  trees = TRUE,\n  quiet = TRUE\n)\n\nOn peut ainsi obtenir le nombre de ré-échantillonnages où chacun des clades de l’arbre par UPGMA apparaît, les transformer en proportions, et affecter ces valeurs aux nœuds internes de l’arbre. On peut alors les afficher sur le dendrogramme.\n\nupgma_bs_scores &lt;- prop.clades(lx_upgma, lx_upgma_bs$trees, rooted = TRUE)\nupgma_support_pct &lt;- upgma_bs_scores / n_bs\nlx_upgma$node.label &lt;- upgma_support_pct\nplot(lx_upgma, show.node.label = TRUE)\n\n\n\n\nUne autre méthodes consiste à directement afficher les résultats avec plotBS().\n\nplotBS(lx_upgma, lx_upgma_bs$trees)\n\n\n\n\nOn peut choisir de n’afficher que les valeurs supérieures à un certain seuil, typiquement 70%.\n\nupgma_support_pct[upgma_support_pct &lt; .7] &lt;- NA\nlx_upgma$node.label &lt;- upgma_support_pct\nplot(lx_upgma, show.node.label = TRUE)\n\n\n\n\nOu plus simplement avec plotBS():\n\nplotBS(lx_upgma, lx_upgma_bs$trees, p = 70)\n\n\n\n\nUn arbre parcimonieux obtenu avec pratchet() contient déjà des valeurs de bootstrap.\n\nlx_mp &lt;- read_rds(\"lx_mp.rds\")\nplotBS(lx_mp, p = .7)"
  },
  {
    "objectID": "evaluation.html#résumer-laccord-entre-des-résultats",
    "href": "evaluation.html#résumer-laccord-entre-des-résultats",
    "title": "\n4  Évaluation des résultats\n",
    "section": "\n4.2 Résumer l’accord entre des résultats",
    "text": "4.2 Résumer l’accord entre des résultats\nUne analyse phylogénétique résulte souvent non pas en un arbre unique mais en un ensemble d’arbres. Ce n’est le cas avec les résultats de nos analyses précédentes, mais on peut générer des données aléatoires pour l’exemple.\n\ntrees &lt;- map(1:3, ~ rtree(n = 9))\ntrees &lt;- as.multiPhylo(c(trees[1], trees[1], trees[1], trees, trees))\n\nIl est possible de résumer l’accord entre ces arbres par un arbre consensus qui ne contient que les clades présents dans une proportion p des arbres. Un arbre consensus est donc normalement moins résolu que les arbres obtenus.\nUn arbre consensus strict ne contient que les clades présents dans tous les arbres (p = 1), ce qui peut parfois aboutir à un «râteau» sans aucun clade à l’intérieur de l’arbre comme ici avec nos données aléatoires.\n\n\nUn arbre consensus n’a pas en principe de longueurs de branches.\n\ntree_sc &lt;- consensus(trees, p = 1)\nplot(tree_sc)\n\n\n\n\nUn arbre consensus majoritaire contient lui les clades présents dans la majorité (p ≥ .5) des arbres.\n\ntree_mc &lt;- consensus(trees, p = .5)\nplot(tree_mc)"
  },
  {
    "objectID": "evaluation.html#mesures-dhomoplasie-et-de-cohérence",
    "href": "evaluation.html#mesures-dhomoplasie-et-de-cohérence",
    "title": "\n4  Évaluation des résultats\n",
    "section": "\n4.3 Mesures d’homoplasie et de cohérence",
    "text": "4.3 Mesures d’homoplasie et de cohérence\nIl est possible de calculer l’indice de cohérence (consistency index, ci) d’un caractère avec un arbre. Un caractère est cohérent avec un arbre si cet arbre implique que le caractère a évolué avec le minimum de transformations possibles pour rendre compte de ces états. Ce minimum m est l’amplitude du caractère, et pour un caractère avec k états possible, il est égal à \\(k - 1\\). L’indice de cohérence se calcule comme le rapport de l’amplitude m sur le nombre de pas (transformations) s observé pour ce caractère.\n\\(ci = \\frac{m}{s}\\)\nLa fonction CI() avec l’option sitewise permet d’obtenir l’index de cohérence de chaque caractère d’une matrice phylogénétique. On obtient une valeur NaN quand il y a une division par 0, dans les cas de caractères sans transformation qui présentent le même état dans tous les taxons.\n\nci &lt;- CI(lx_pratchet[[1]], lx_phy, sitewise = TRUE)\nci\n\n  [1] 1.0000000       NaN 1.0000000 0.6666667       NaN       NaN       NaN\n  [8]       NaN       NaN       NaN 1.0000000 0.7500000       NaN 1.0000000\n [15] 1.0000000 0.6666667       NaN       NaN       NaN       NaN 1.0000000\n [22]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n [29]       NaN       NaN       NaN       NaN       NaN 0.5000000 1.0000000\n [36] 1.0000000       NaN       NaN       NaN       NaN       NaN       NaN\n [43]       NaN       NaN 1.0000000       NaN 1.0000000       NaN       NaN\n [50]       NaN 1.0000000       NaN       NaN       NaN 0.3333333 0.5000000\n [57]       NaN 1.0000000       NaN 1.0000000 0.8000000 1.0000000 1.0000000\n [64]       NaN 1.0000000 1.0000000       NaN 0.5000000 1.0000000       NaN\n [71] 1.0000000 0.5000000       NaN       NaN       NaN 0.7500000       NaN\n [78]       NaN 1.0000000       NaN       NaN       NaN 1.0000000 1.0000000\n [85] 0.7500000 0.7500000       NaN       NaN       NaN       NaN       NaN\n [92] 0.7500000       NaN       NaN       NaN 1.0000000       NaN 0.5000000\n [99]       NaN       NaN       NaN 1.0000000       NaN       NaN       NaN\n[106]       NaN       NaN       NaN       NaN 1.0000000\n\n\nLe nombre d’homoplasies h pour un caractère s’obtient par \\(h = l - r\\). La valeur de r se calcule avec une fonction cachée de phangorn, et celle de l avec la fonction sankoff() et l’option site = \"site\". En raison de la manière dont sont traités en interne les caractères de la matrice phylogénétique, il faut jouer avec les index de l’objet PhyDat pour bien récupérer la liste complète des valeurs.\n\nm &lt;- phangorn:::lowerBound(lx_phy)[attr(lx_phy, \"index\")]\ns &lt;- sankoff(lx_pratchet[[1]], lx_phy, site = \"site\")[attr(lx_phy, \"index\")]\nh &lt;- s - m\nh\n\n  [1] 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0\n [38] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0\n [75] 0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0\n\nH &lt;- sum(h)\nH\n\n[1] 16\n\n\nOn peut alors obtenir le numéro des caractères présentant de l’homoplasie:\n\nwhich(h &gt; 0)\n\n [1]  4 12 16 34 55 56 61 68 72 76 85 86 92 98\n\n\nL’indice de cohérence CI de l’ensemble des caractères est lui le rapport de la somme M des m sur la somme S des s de tous les N caractères.\n\\[CI = \\frac{M}{S}, M = \\sum^N_{i=1} m_i, S = \\sum^N_{i=1} s_i\\]\n\nCI(lx_pratchet[[1]], lx_phy)\n\n[1] 0.8431373\n\nsum(m)/sum(s)\n\n[1] 0.8431373\n\n\nS est le nombre total de pas ou longueur de l’arbre. On peut l’obtenir avec la fonction sankoff() sans option.\n\nsum(s)\n\n[1] 102\n\nsankoff(lx_pratchet[[1]], lx_phy)\n\n[1] 102\n\n\nCet indice de cohérence est une mesure du degré d’homoplasie des données sur un arbre. Plus le score est bas, plus l’arbre contient d’homoplasie, et une valeur de 1 indique une absence totale d’homoplasie. Les caractères autapomorphiques ont un ci de 1.\nL’indice de cohérence est cependant problématique car sa valeur minimale n’est en fait pas 0, ce qui ne permet donc pas de l’utiliser pour évaluer correctement le degré d’homoplasie.\nIl est possible d’utiliser à la place un indice de cohérence mis à l’échelle (rescaled consistency index, rci) par l’introduction de g, le nombre maximal de transformations pour un caractère, ce qui correspond cas où toutes les transformations auraient lieu sur les branches terminales:\n\\[rci = \\frac{g-s}{g-m}\\frac{m}{s} = \\frac{g-s}{g-m}ci\\]\nLes valeurs de g s’obtient avec une autre fonction cachée de phangorn.\n\ng &lt;- phangorn:::upperBound(lx_phy)[attr(lx_phy, \"index\")]\ng\n\n  [1] 6 0 1 3 0 0 0 0 0 0 1 5 0 6 1 4 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 3 4 1 0\n [38] 0 0 0 0 0 0 0 2 0 6 0 0 0 1 0 0 0 4 2 0 4 0 5 6 4 1 0 4 1 0 2 1 0 4 4 0 0\n [75] 0 5 0 0 3 0 0 0 7 4 6 5 0 0 0 0 0 6 0 0 0 2 0 4 0 0 0 1 0 0 0 0 0 0 0 3\n\n\nMais il est plus simple de calculer la partie gauche de la formule du rci avec la fonction RI().\n\nrci &lt;- RI(lx_pratchet[[1]], lx_phy, sitewise = TRUE) * CI(lx_pratchet[[1]], lx_phy, sitewise = TRUE)\nrci\n\n  [1] 1.0000000       NaN       NaN 0.0000000       NaN       NaN       NaN\n  [8]       NaN       NaN       NaN       NaN 0.3750000       NaN 1.0000000\n [15]       NaN 0.3333333       NaN       NaN       NaN       NaN       NaN\n [22]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n [29]       NaN       NaN       NaN       NaN       NaN 0.2500000 1.0000000\n [36]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n [43]       NaN       NaN 1.0000000       NaN 1.0000000       NaN       NaN\n [50]       NaN       NaN       NaN       NaN       NaN 0.1111111 0.0000000\n [57]       NaN 1.0000000       NaN 1.0000000 0.4000000 1.0000000       NaN\n [64]       NaN 1.0000000       NaN       NaN 0.0000000       NaN       NaN\n [71] 1.0000000 0.3333333       NaN       NaN       NaN 0.3750000       NaN\n [78]       NaN 1.0000000       NaN       NaN       NaN 1.0000000 1.0000000\n [85] 0.5000000 0.3750000       NaN       NaN       NaN       NaN       NaN\n [92] 0.5000000       NaN       NaN       NaN       NaN       NaN 0.0000000\n [99]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n[106]       NaN       NaN       NaN       NaN       NaN\n\n\nL’indice de cohérence mis à l’échelle RCI pour l’ensemble des caractères se calcule comme suit:\n\\[RCI = \\frac{G-S}{G-M}\\frac{M}{S}, G = \\sum^N_{i=1} g_i\\]\n\nCI(lx_pratchet[[1]], lx_phy) * RI(lx_pratchet[[1]], lx_phy)\n\n[1] 0.5678271\n\n\nLe coefficient de distortion d d’un caractère est le nombre d’homoplasies observées par rapport au nombre maximal possible.\n\\[d = \\frac{h}{g - m}\\]\n\nd &lt;- h/(g - m)\nd\n\n  [1] 0.0000000       NaN       NaN 1.0000000       NaN       NaN       NaN\n  [8]       NaN       NaN       NaN       NaN 0.5000000       NaN 0.0000000\n [15]       NaN 0.5000000       NaN       NaN       NaN       NaN       NaN\n [22]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n [29]       NaN       NaN       NaN       NaN       NaN 0.5000000 0.0000000\n [36]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n [43]       NaN       NaN 0.0000000       NaN 0.0000000       NaN       NaN\n [50]       NaN       NaN       NaN       NaN       NaN 0.6666667 1.0000000\n [57]       NaN 0.0000000       NaN 0.0000000 0.5000000 0.0000000       NaN\n [64]       NaN 0.0000000       NaN       NaN 1.0000000       NaN       NaN\n [71] 0.0000000 0.3333333       NaN       NaN       NaN 0.5000000       NaN\n [78]       NaN 0.0000000       NaN       NaN       NaN 0.0000000 0.0000000\n [85] 0.3333333 0.5000000       NaN       NaN       NaN       NaN       NaN\n [92] 0.3333333       NaN       NaN       NaN       NaN       NaN 1.0000000\n [99]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n[106]       NaN       NaN       NaN       NaN       NaN\n\n\nOn peut aussi le calculer pour un ensemble de caractères.\n\nD &lt;- sum(h)/(sum(g) - sum(m))\nD\n\n[1] 0.3265306\n\n\nLa partie gauche des formules d’indice de cohérence est lui-même une mesure appelée indice de rétention (retention index, ri, RI). Il s’agit du complément \\(1 - D\\) de l’indice de distorsion D. Il mesure la proportion d’homoplasies possibles mais non observées, ce qui revient à la proportion de synapomorphies possibles effectivement retenues comme telle sur un arbre. Les caractères autapomorphiques ont un ri de 0.\n\nri &lt;- RI(lx_pratchet[[1]], lx_phy, sitewise = TRUE)\nri\n\n  [1] 1.0000000       NaN       NaN 0.0000000       NaN       NaN       NaN\n  [8]       NaN       NaN       NaN       NaN 0.5000000       NaN 1.0000000\n [15]       NaN 0.5000000       NaN       NaN       NaN       NaN       NaN\n [22]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n [29]       NaN       NaN       NaN       NaN       NaN 0.5000000 1.0000000\n [36]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n [43]       NaN       NaN 1.0000000       NaN 1.0000000       NaN       NaN\n [50]       NaN       NaN       NaN       NaN       NaN 0.3333333 0.0000000\n [57]       NaN 1.0000000       NaN 1.0000000 0.5000000 1.0000000       NaN\n [64]       NaN 1.0000000       NaN       NaN 0.0000000       NaN       NaN\n [71] 1.0000000 0.6666667       NaN       NaN       NaN 0.5000000       NaN\n [78]       NaN 1.0000000       NaN       NaN       NaN 1.0000000 1.0000000\n [85] 0.6666667 0.5000000       NaN       NaN       NaN       NaN       NaN\n [92] 0.6666667       NaN       NaN       NaN       NaN       NaN 0.0000000\n [99]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n[106]       NaN       NaN       NaN       NaN       NaN\n\nRI &lt;- RI(lx_pratchet[[1]], lx_phy)\nRI\n\n[1] 0.6734694\n\n1 - D\n\n[1] 0.6734694\n\n\nIl est ainsi possible de comparer les scores de différents arbres, par exemple ceux obtenus par parcimonie et celui obtenu par UPGMA.\n\ntr &lt;- c(lx_pratchet, lx_sc, lx_mc, lx_upgma)\nnms &lt;- c(1:4, \"Strict\", \"Majority\", \"UPGMA\")\ncomp_tb &lt;- map(seq_along(tr), function(i){\n  m_x &lt;- phangorn:::lowerBound(lx_phy)[attr(lx_phy, \"index\")]\n  s_x &lt;- sankoff(tr[[i]], lx_phy, site = \"site\")[attr(lx_phy, \"index\")]\n  h_x &lt;- s_x - m_x\n  CI_x &lt;- CI(tr[[i]], lx_phy)\n  RI_x &lt;- RI(tr[[i]], lx_phy)\n  df &lt;- tribble(\n    ~var, ~value,\n  \"S\", sum(s_x),\n  \"H\", sum(h_x),\n  \"CI\", CI_x,\n  \"RCI\", CI_x * RI_x,\n  \"RI\", RI_x,\n  \"D\", 1 - RI_x\n  )\n  colnames(df)[2] &lt;- nms[i]\n  df\n}) %&gt;% \n  reduce(left_join)\n\n\n\n\n\n  \n\n\n\nLes résultats sont similaires, mais le 4e arbre obtenu par parcimonie contient moins d’homoplasies et a des meilleurs scores de CI, RCI et RI. On remarque donc que l’option all = TRUE de pratchet() donne un ensemble d’arbres qui ne sont pas tous aussi parcimonieux les uns que les autres."
  },
  {
    "objectID": "bibliographie.html",
    "href": "bibliographie.html",
    "title": "Bibliographie",
    "section": "",
    "text": "Atkinson, Quentin D. & Russell D. Gray. 2005. Curious parallels and\ncurious connections: Phylogenetic thinking in biology and historical\nlinguistics. Systematic Biology 54(4). 513–526. https://doi.org/10.1080/10635150590950317.\n\n\nAubert, Damien. 2017. Classer le vivant: Les perspectives de la\nsystématique évolutionniste moderne. Paris: Ellipses.\n\n\nBrower, Andrew V. Z. & Randall T. Schuh. 2021. Biological\nsystematics: Principles and applications. 3. edn. Ithaca: Comstock.\n\n\nDarlu, Pierre, Pascal Tassy & René Zaragüeta i Bagils. 2019. La\nreconstruction phylogénétique: Concepts et méthodes. 2. edn. Paris:\nÉditions Matériologiques.\n\n\nDunn, Michael. 2015. Language phylogenies. In Claire Bowern &\nBethwyn Evans (Hrsg.), The Routledge handbook of historical\nlinguistics, 190–211. London: Routledge. https://doi.org/10.4324/9781315794013.\n\n\nFelsenstein, Joseph. 2004. Inferring phylogenies. Sunderland:\nSinauer.\n\n\nGeisler, Hans & Johann-Mattis List. 2013. Do languages grow on\ntrees? The tree metaphor in the history of linguistics. In Heiner\nFangerau, Hans Geisler, Thorsten Halling & William Martin (Hrsg.),\nClassification and evolution in biology, linguistics and the history\nof science, 111–124. Stuttgart: Steiner.\n\n\nGoldstein. 2020. Indo-European phylogenetics with R: A tutorial\nintroduction. Journal of Indo-European Linguistics. https://doi.org/10.1163/22125892-20201000.\n\n\nGregory, T. Ryan. 2008. Understanding evolutionary trees. Evolution:\nEducation and Outreach 1(2). 121–137. https://doi.org/10.1007/s12052-008-0035-x.\n\n\nGrolemund, Garrett. 2014. Hands-on programming with R: Write your\nown functions and simulations. Sebastopol: O’Reilly Media. https://rstudio-education.github.io/hopr/.\n\n\nHervé, Maxime. 2020. Systématique animale: D’Aristote aux\nphylogénies moléculaires. Histoire, concepts et méthodes de la\nclassification. Louvain-la-Neuve: De Boeck Supérieur.\n\n\nJacques, Guillaume & Johann-Mattis List. 2019. Save the trees: Why\nwe need tree models in linguistic reconstruction (and when we should\napply them). Journal of Historical Linguistics 9(1). 128–166.\nhttps://doi.org/10.1075/jhl.17008.mat.\n\n\nLemey, Philippe, Marco Salemi & Anne-Mieke Vandamme (Hrsg.). 2009.\nThe phylogenetic handbook: A practical approach to phylogenetic\nanalysis and hypothesis testing. 2. edn. Cambridge: Cambridge\nUniversity Press. https://doi.org/10.1017/CBO9780511819049.\n\n\nPerrière, Guy & Céline Brochier-Armanet. 2010. Concepts et\nméthodes en phylogénie moléculaire. Paris: Springer.\n\n\nWickham, Hadley & Garrett Grolemund. 2017. R for data science:\nImport, tidy, transform, visualize, and model data. Sebastopol:\nO’Reilly Media. http://r4ds.had.co.nz/.\n\n\nWickham, Hadley & Garrett Grolemund. 2018. R pour les data\nsciences: Importer, classer, transformer, visualiser et modéliser les\ndonnées. Paris: Eyrolles."
  },
  {
    "objectID": "parcimonie.html#mesures-dhomoplasie-et-de-cohérence",
    "href": "parcimonie.html#mesures-dhomoplasie-et-de-cohérence",
    "title": "\n3  Méthodes de parcimonie\n",
    "section": "\n3.2 Mesures d’homoplasie et de cohérence",
    "text": "3.2 Mesures d’homoplasie et de cohérence\nIl est possible de calculer l’indice de cohérence (consistency index, ci) d’un caractère avec un arbre. Un caractère est cohérent avec un arbre si cet arbre implique que le caractère a évolué avec le minimum de transformations possibles pour rendre compte de ces états. Ce minimum m est l’amplitude du caractère, et pour un caractère avec k états possible, il est égal à \\(k - 1\\). L’indice de cohérence se calcule comme le rapport de l’amplitude m sur le nombre de pas (transformations) s observé pour ce caractère.\n\\(ci = \\frac{m}{s}\\)\nLa fonction CI() avec l’option sitewise permet d’obtenir l’index de cohérence de chaque caractère d’une matrice phylogénétique. On obtient une valeur NaN quand il y a une division par 0, dans les cas de caractères sans transformation qui présentent le même état dans tous les taxons.\n\nci &lt;- CI(lx_mp_r, lx_phy, sitewise = TRUE)\nci\n\n  [1] 1.0000000       NaN 1.0000000 0.6666667       NaN       NaN       NaN\n  [8]       NaN       NaN       NaN 1.0000000 0.7500000       NaN 1.0000000\n [15] 1.0000000 1.0000000       NaN       NaN       NaN       NaN 1.0000000\n [22]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n [29]       NaN       NaN       NaN       NaN       NaN 0.5000000 1.0000000\n [36] 1.0000000       NaN       NaN       NaN       NaN       NaN       NaN\n [43]       NaN       NaN 1.0000000       NaN 1.0000000       NaN       NaN\n [50]       NaN 1.0000000       NaN       NaN       NaN 0.3333333 0.5000000\n [57]       NaN 1.0000000       NaN 1.0000000 1.0000000 1.0000000 1.0000000\n [64]       NaN 1.0000000 1.0000000       NaN 0.5000000 1.0000000       NaN\n [71] 1.0000000 0.5000000       NaN       NaN       NaN 0.7500000       NaN\n [78]       NaN 1.0000000       NaN       NaN       NaN 1.0000000 1.0000000\n [85] 0.6000000 1.0000000       NaN       NaN       NaN       NaN       NaN\n [92] 0.7500000       NaN       NaN       NaN 1.0000000       NaN 0.5000000\n [99]       NaN       NaN       NaN 1.0000000       NaN       NaN       NaN\n[106]       NaN       NaN       NaN       NaN 1.0000000\n\n\nLe nombre d’homoplasies h pour un caractère s’obtient par \\(h = l - r\\). La valeur de r se calcule avec une fonction cachée de phangorn, et celle de l avec la fonction sankoff() et l’option site = \"site\". En raison de la manière dont sont traités en interne les caractères de la matrice phylogénétique, il faut jouer avec les index de l’objet PhyDat pour bien récupérer la liste complète des valeurs.\n\nm &lt;- phangorn:::lowerBound(lx_phy)[attr(lx_phy, \"index\")]\ns &lt;- sankoff(lx_mp_r, lx_phy, site = \"site\")[attr(lx_phy, \"index\")]\nh &lt;- s - m\nh\n\n  [1] 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0\n [38] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0\n [75] 0 1 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 1 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0\n\nH &lt;- sum(h)\nH\n\n[1] 14\n\n\nOn peut alors obtenir le numéro des caractères présentant de l’homoplasie:\n\nwhich(h &gt; 0)\n\n [1]  4 12 34 55 56 68 72 76 85 92 98\n\n\nL’indice de cohérence CI de l’ensemble des caractères est lui le rapport de la somme M des m sur la somme S des s de tous les N caractères.\n\\[CI = \\frac{M}{S}, M = \\sum^N_{i=1} m_i, S = \\sum^N_{i=1} s_i\\]\n\nCI(lx_mp_r, lx_phy)\n\n[1] 0.86\n\nsum(m)/sum(s)\n\n[1] 0.86\n\n\nS est le nombre total de pas ou longueur de l’arbre. On peut l’obtenir avec la fonction sankoff() sans option.\n\nsum(s)\n\n[1] 100\n\nsankoff(lx_mp_r, lx_phy)\n\n[1] 100\n\n\nCet indice de cohérence est une mesure du degré d’homoplasie des données sur un arbre. Plus le score est bas, plus l’arbre contient d’homoplasie, et une valeur de 1 indique une absence totale d’homoplasie. Les caractères autapomorphiques ont un ci de 1.\nL’indice de cohérence est cependant problématique car sa valeur minimale n’est en fait pas 0, ce qui ne permet donc pas de l’utiliser pour évaluer correctement le degré d’homoplasie.\nIl est possible d’utiliser à la place un indice de cohérence mis à l’échelle (rescaled consistency index, rci) par l’introduction de g, le nombre maximal de transformations pour un caractère, ce qui correspond cas où toutes les transformations auraient lieu sur les branches terminales:\n\\[rci = \\frac{g-s}{g-m}\\frac{m}{s} = \\frac{g-s}{g-m}ci\\]\nLes valeurs de g s’obtient avec une autre fonction cachée de phangorn.\n\ng &lt;- phangorn:::upperBound(lx_phy)[attr(lx_phy, \"index\")]\ng\n\n  [1] 6 0 1 3 0 0 0 0 0 0 1 5 0 6 1 4 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 3 4 1 0\n [38] 0 0 0 0 0 0 0 2 0 6 0 0 0 1 0 0 0 4 2 0 4 0 5 6 4 1 0 4 1 0 2 1 0 4 4 0 0\n [75] 0 5 0 0 3 0 0 0 7 4 6 5 0 0 0 0 0 6 0 0 0 2 0 4 0 0 0 1 0 0 0 0 0 0 0 3\n\n\nMais il est plus simple de calculer la partie gauche de la formule du rci avec la fonction RI().\n\nrci &lt;- RI(lx_mp_r, lx_phy, sitewise = TRUE) * CI(lx_mp_r, lx_phy, sitewise = TRUE)\nrci\n\n  [1] 1.0000000       NaN       NaN 0.0000000       NaN       NaN       NaN\n  [8]       NaN       NaN       NaN       NaN 0.3750000       NaN 1.0000000\n [15]       NaN 1.0000000       NaN       NaN       NaN       NaN       NaN\n [22]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n [29]       NaN       NaN       NaN       NaN       NaN 0.2500000 1.0000000\n [36]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n [43]       NaN       NaN 1.0000000       NaN 1.0000000       NaN       NaN\n [50]       NaN       NaN       NaN       NaN       NaN 0.1111111 0.0000000\n [57]       NaN 1.0000000       NaN 1.0000000 1.0000000 1.0000000       NaN\n [64]       NaN 1.0000000       NaN       NaN 0.0000000       NaN       NaN\n [71] 1.0000000 0.3333333       NaN       NaN       NaN 0.3750000       NaN\n [78]       NaN 1.0000000       NaN       NaN       NaN 1.0000000 1.0000000\n [85] 0.2000000 1.0000000       NaN       NaN       NaN       NaN       NaN\n [92] 0.5000000       NaN       NaN       NaN       NaN       NaN 0.0000000\n [99]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n[106]       NaN       NaN       NaN       NaN       NaN\n\n\nL’indice de cohérence mis à l’échelle RCI pour l’ensemble des caractères se calcule comme suit:\n\\[RCI = \\frac{G-S}{G-M}\\frac{M}{S}, G = \\sum^N_{i=1} g_i\\]\n\nCI(lx_mp_r, lx_phy) * RI(lx_mp_r, lx_phy)\n\n[1] 0.6142857\n\n\nLe coefficient de distortion d d’un caractère est le nombre d’homoplasies observées par rapport au nombre maximal possible.\n\\[d = \\frac{h}{g - m}\\]\n\nd &lt;- h/(g - m)\nd\n\n  [1] 0.0000000       NaN       NaN 1.0000000       NaN       NaN       NaN\n  [8]       NaN       NaN       NaN       NaN 0.5000000       NaN 0.0000000\n [15]       NaN 0.0000000       NaN       NaN       NaN       NaN       NaN\n [22]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n [29]       NaN       NaN       NaN       NaN       NaN 0.5000000 0.0000000\n [36]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n [43]       NaN       NaN 0.0000000       NaN 0.0000000       NaN       NaN\n [50]       NaN       NaN       NaN       NaN       NaN 0.6666667 1.0000000\n [57]       NaN 0.0000000       NaN 0.0000000 0.0000000 0.0000000       NaN\n [64]       NaN 0.0000000       NaN       NaN 1.0000000       NaN       NaN\n [71] 0.0000000 0.3333333       NaN       NaN       NaN 0.5000000       NaN\n [78]       NaN 0.0000000       NaN       NaN       NaN 0.0000000 0.0000000\n [85] 0.6666667 0.0000000       NaN       NaN       NaN       NaN       NaN\n [92] 0.3333333       NaN       NaN       NaN       NaN       NaN 1.0000000\n [99]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n[106]       NaN       NaN       NaN       NaN       NaN\n\n\nOn peut aussi le calculer pour un ensemble de caractères.\n\nD &lt;- sum(h)/(sum(g) - sum(m))\nD\n\n[1] 0.2857143\n\n\nLa partie gauche des formules d’indice de cohérence est lui-même une mesure appelée indice de rétention (retention index, ri, RI). Il s’agit du complément \\(1 - D\\) de l’indice de distorsion D. Il mesure la proportion d’homoplasies possibles mais non observées, ce qui revient à la proportion de synapomorphies possibles effectivement retenues comme telle sur un arbre. Les caractères autapomorphiques ont un ri de 0.\n\nri &lt;- RI(lx_mp_r, lx_phy, sitewise = TRUE)\nri\n\n  [1] 1.0000000       NaN       NaN 0.0000000       NaN       NaN       NaN\n  [8]       NaN       NaN       NaN       NaN 0.5000000       NaN 1.0000000\n [15]       NaN 1.0000000       NaN       NaN       NaN       NaN       NaN\n [22]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n [29]       NaN       NaN       NaN       NaN       NaN 0.5000000 1.0000000\n [36]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n [43]       NaN       NaN 1.0000000       NaN 1.0000000       NaN       NaN\n [50]       NaN       NaN       NaN       NaN       NaN 0.3333333 0.0000000\n [57]       NaN 1.0000000       NaN 1.0000000 1.0000000 1.0000000       NaN\n [64]       NaN 1.0000000       NaN       NaN 0.0000000       NaN       NaN\n [71] 1.0000000 0.6666667       NaN       NaN       NaN 0.5000000       NaN\n [78]       NaN 1.0000000       NaN       NaN       NaN 1.0000000 1.0000000\n [85] 0.3333333 1.0000000       NaN       NaN       NaN       NaN       NaN\n [92] 0.6666667       NaN       NaN       NaN       NaN       NaN 0.0000000\n [99]       NaN       NaN       NaN       NaN       NaN       NaN       NaN\n[106]       NaN       NaN       NaN       NaN       NaN\n\nRI &lt;- RI(lx_mp_r, lx_phy)\nRI\n\n[1] 0.7142857\n\n1 - D\n\n[1] 0.7142857\n\n\nIl est ainsi possible de comparer les scores de différents arbres, par exemple celui obtenu par parcimonie et celui obtenu par UPGMA.\n\nlx_upgma &lt;- read.tree(\"lx_upgma.tree\")\ntr &lt;- c(lx_mp_r, lx_upgma)\nnms &lt;- c(\"MP\", \"UPGMA\")\ncomp_tb &lt;- map(seq_along(tr), function(i){\n  m_x &lt;- phangorn:::lowerBound(lx_phy)[attr(lx_phy, \"index\")]\n  s_x &lt;- sankoff(tr[[i]], lx_phy, site = \"site\")[attr(lx_phy, \"index\")]\n  h_x &lt;- s_x - m_x\n  CI_x &lt;- CI(tr[[i]], lx_phy)\n  RI_x &lt;- RI(tr[[i]], lx_phy)\n  df &lt;- tribble(\n    ~var, ~value,\n  \"S\", sum(s_x),\n  \"H\", sum(h_x),\n  \"CI\", CI_x,\n  \"RCI\", CI_x * RI_x,\n  \"RI\", RI_x,\n  \"D\", 1 - RI_x\n  )\n  colnames(df)[2] &lt;- nms[i]\n  df\n}) %&gt;% \n  reduce(left_join)\n\n\n\n\n\n  \n\n\n\nLes résultats sont similaires, mais, sans surprise, l’arbre obtenu par parcimonie contient moins d’homoplasies et a des meilleurs scores de CI, RCI et RI que celui obtenu par UPGMA."
  },
  {
    "objectID": "parcimonie.html#parcimonie-générale",
    "href": "parcimonie.html#parcimonie-générale",
    "title": "\n3  Méthodes de parcimonie\n",
    "section": "\n3.1 Parcimonie générale",
    "text": "3.1 Parcimonie générale\nCommençons par importer de nouveau la matrice de traits à états multiples que nous avions sauvegardée précédemment.\n\nlibrary(tidyverse)\nlibrary(phangorn)\nlibrary(TreeTools)\nlx_phy &lt;- ReadAsPhyDat(\"lx_phy_multi.nex\")\n\nParmi les différentes variantes de parcimonie, la plus simple (dite «de Wagner») autorise tous les changements sans restriction et les traite à égalité sans pondération, orientation, ou ordre. Dans le cas d’une matrice de traits binaires, les changements 0 &gt; 1 et 1 &gt; 0 sont ainsi traités de manière identique, et il n’est pas nécessaire de connaitre l’état ancestral de chaque trait et si un changement constitue une innovation ou une réversion, ce qui implique que le résultat est un arbre non enraciné.\n\n\n\n\n\n\n\n\nÀ faire\n\n\n\nInclure les autres types de parcimonie.\n\n\nLa comparaison des arbres possibles à la recherche du plus parcimonieux est une procédure longue, et avec beaucoup de taxons, il est nécessaire d’utiliser une méthode heuristique comme le Parsimony Ratchet avec pratchet(). Le résultat est un objet multiPhylo pouvant contenir plusieurs arbres si l’on a précisé l’option all = TRUE, bien qu’ici il n’y en ait qu’un seul.\n\n\n\n\n\n\n\n\nÀ faire\n\n\n\nVérifier le traitement des données manquantes et celui des polymorphismes pour les données à états multiples.\n\n\n\nlx_mp &lt;- pratchet(lx_phy, trace = 0, minit = 1000, k = 100, method = \"sankoff\", all = TRUE)\nlx_mp\n\n\nPhylogenetic tree with 9 tips and 7 internal nodes.\n\nTip labels:\n  Bleu, Magenta, Rouge, Jaune, Orange, Vert, ...\nNode labels:\n  1, 0.658, 0.988, 0.993, 0.995, 0.78, ...\n\nUnrooted; no branch lengths.\n\nplot(lx_mp, \"unrooted\")\n\n\n\n\n\n\n\n\n\n\n\n\nL’option trace permet de choisir la quantité d’information à afficher concernant la recherche de l’arbre.\n\n\n\n\n\n\n\n\n\nL’option method = \"sankoff\" permet d’utiliser l’algorithme de Sankoff qui est plus complexe mais plus général également.\n\n\n\nIl est nécessaire de calculer explicitement la longueur des différentes branches. La fonction acctran() permet de calculer la longueur par la méthode de transformation accélérée qui assigne les changements le plus haut possible dans l’arbre et favorise l’interprétation des homoplasies comme des réversions.\n\nlx_mp_bl &lt;- acctran(lx_mp, lx_phy)\nlx_mp_bl\n\n\nPhylogenetic tree with 9 tips and 7 internal nodes.\n\nTip labels:\n  Bleu, Magenta, Rouge, Jaune, Orange, Vert, ...\nNode labels:\n  1, 0.658, 0.988, 0.993, 0.995, 0.78, ...\n\nUnrooted; includes branch lengths.\n\nplot(lx_mp_bl, \"unrooted\")\n\n\n\n\nOn peut ensuite enraciner l’arbre, par exemple avec midpoint(), qui place la racine à mi-chemin des deux taxons les plus divergents. Cette méthode présuppose cependant que l’évolution a lieu a taux constant et que la topologie est équilibrée (les taxons sont bien distribués entre les différents clades).\n\nplot(midpoint(lx_mp_bl))\n\n\n\n\nUne autre méthode nécessite de déterminer un extra-groupe ou groupe externe (outgroup). La fonction root() permet de procéder à l’enracinement en indiquant le numéro ou le nom du taxon constituant le groupe externe, par exemple «Violet». Cela présuppose bien sûr qu’il ait été inclus dans l’analyse de départ.\n\nlx_mp_r &lt;- RootTree(lx_mp, \"Violet\") %&gt;% \n  acctran(lx_phy)\nplot(lx_mp_r)\n\n\n\n\nOn peut alors sauvegarder les résultats (arbres avec longueurs de branches) dans un fichier au format Newick. Sauvegardons le résultat également comme un objet R, afin de conserver des propriétés intéressantes pour plus tard.\n\nwrite.tree(lx_mp_r, \"lx_mp.tree\")\nwrite_rds(lx_mp_r, \"lx_mp.rds\")"
  }
]